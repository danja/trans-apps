================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-09-11T16:58:31.749Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
Transmissions repo

================================================================
Repository Files
================================================================

================
File: .github/workflows/test.yaml
================
name: Test
on:
  - pull_request
  - push
jobs:
  test:
    runs-on: ubuntu-20.04
    strategy:
      matrix:
        node:
          - '18'
          - '20'
          - '21'
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node }}
      - run: npm install
      - run: npm test
      - uses: codecov/codecov-action@v3

================
File: LICENSE.md
================
MIT License

Copyright (c) 2023 Thomas Bergwinkl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# rdf-utils-fs

[![build status](https://img.shields.io/github/actions/workflow/status/rdf-ext/rdf-utils-fs/test.yaml?branch=master)](https://github.com/rdf-ext/rdf-utils-fs/actions/workflows/test.yaml)
[![npm version](https://img.shields.io/npm/v/rdf-utils-fs.svg)](https://www.npmjs.com/package/rdf-utils-fs)

File system utils for RDF/JS.

## Usage

Each util function can be loaded as property from the main module or by loading only the file with the same name.

### Example

Loading the function from the main module:

```javascript
import { fromFile } from 'rdf-utils-fs'
import { toFile } from 'rdf-utils-fs'
```
 
Loading the function from the file with the function name:

```javascript
import fromFile from 'rdf-utils-fs/fromFile.js'
import toFile from 'rdf-utils-fs/toFile.js'
```
 
## Functions

### fromFile(filename, options)

Returns a quad stream for the given `filename`.

### async toFile(stream, filename, options)

Writes the given quad stream to `filename`.

================
File: defaults.js
================
const defaults = {}
defaults.extensions = {
  json: 'application/ld+json',
  jsonld: 'application/ld+json',
  nq: 'application/n-quads',
  nt: 'application/n-triples',
  n3: 'text/turtle',
  trig: 'application/trig',
  rdf: 'application/rdf+xml',
  ttl: 'text/turtle'
}
export default defaults

================
File: fromFile.js
================
import { createReadStream } from 'node:fs'
import { extname } from 'node:path'
import formats from '@rdfjs/formats-common'
import defaults from './defaults.js'
function fromFile (filename, { extensions, ...options } = {}) {
  const combinedExtensions = {
    ...defaults.extensions,
    ...extensions
  }
  const extension = extname(filename).split('.').pop()
  const mediaType = combinedExtensions[extension]
  if (!mediaType) {
    throw new Error(`Unknown file extension: ${extension}`)
  }
  const parser = formats.parsers.get(mediaType)
  if (!parser) {
    throw new Error(`No parser available for media type: ${mediaType}`)
  }
  return parser.import(createReadStream(filename), options)
}
export default fromFile

================
File: index.js
================
import fromFile from './fromFile.js'
import toFile from './toFile.js'
export {
  fromFile,
  toFile
}

================
File: package.json
================
{
  "name": "rdf-utils-fs",
  "version": "3.0.0",
  "description": "RDF/JS file system utils",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "coverage": "codecov",
    "test": "stricter-standard && c8 --reporter=lcov --reporter=text-summary mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/rdf-ext/rdf-utils-fs.git"
  },
  "keywords": [
    "rdf",
    "rdfjs",
    "fs",
    "utils"
  ],
  "author": "Thomas Bergwinkl <bergi@axolotlfarm.org> (https://www.bergnet.org/people/bergi/card#me)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/rdf-ext/rdf-utils-fs/issues"
  },
  "homepage": "https://github.com/rdf-ext/rdf-utils-fs",
  "dependencies": {
    "@rdfjs/formats-common": "^3.1.0",
    "readable-stream": "^4.4.2"
  },
  "devDependencies": {
    "c8": "^8.0.1",
    "is-stream": "^3.0.0",
    "mocha": "^10.2.0",
    "rdf-ext": "^2.4.0",
    "shelljs": "^0.8.5",
    "stricter-standard": "^0.3.0"
  }
}

================
File: test/fromFile.test.js
================
import { strictEqual, throws } from 'node:assert'
import { isReadableStream } from 'is-stream'
import { describe, it } from 'mocha'
import rdf from 'rdf-ext'
import fromFile from '../fromFile.js'
import * as example from './support/example.js'
describe('fromFile', () => {
  it('should create a quad stream', async () => {
    const stream = fromFile(new URL('support/example.nt', import.meta.url).pathname)
    stream.resume()
    strictEqual(isReadableStream(stream), true)
  })
  it('should forward options to parser', async () => {
    const stream = fromFile(new URL('support/example.ttl', import.meta.url).pathname, { baseIRI: 'http://example.org/' })
    const dataset = await rdf.dataset().import(stream)
    strictEqual(dataset.toCanonical(), example.defaultGraph().toCanonical())
  })
  it('should combine extensions with default', async () => {
    const extensions = {
      trig: 'application/trig'
    }
    const stream = fromFile(new URL('support/example.nt', import.meta.url).pathname, { extensions })
    const dataset = await rdf.dataset().import(stream)
    strictEqual(dataset.toCanonical(), example.defaultGraph().toCanonical())
  })
  const commonExtensions = [
    ['json', example.defaultGraph],
    ['jsonld', example.namedGraph],
    ['n3', example.defaultGraph],
    ['trig', example.namedGraph],
    ['nq', example.namedGraph]
  ]
  for (const [extension, expected] of commonExtensions) {
    it(`should load ${extension} out of the box`, async () => {
      const stream = fromFile(new URL(`support/example.${extension}`, import.meta.url).pathname)
      const dataset = await rdf.dataset().import(stream)
      strictEqual(dataset.toCanonical(), expected().toCanonical())
    })
  }
  it('should throw an error if the file extension is unknown', () => {
    throws(() => {
      fromFile('test.jpg')
    })
  })
  it('should throw an error if the media type is unknown', () => {
    throws(() => {
      fromFile('test.jpg', {
        extensions: {
          jpg: 'image/jpeg'
        }
      })
    })
  })
})

================
File: test/support/example.js
================
import rdf from 'rdf-ext'
function defaultGraph () {
  return rdf.dataset([rdf.quad(
    rdf.namedNode('http://example.org/subject'),
    rdf.namedNode('http://example.org/predicate'),
    rdf.literal('object')
  )])
}
function namedGraph () {
  return rdf.dataset([rdf.quad(
    rdf.namedNode('http://example.org/subject'),
    rdf.namedNode('http://example.org/predicate'),
    rdf.literal('object'),
    rdf.namedNode('http://example.org/subject')
  )])
}
export {
  defaultGraph,
  namedGraph
}

================
File: test/support/example.json
================
{
  "@id": "http://example.org/subject",
  "http://example.org/predicate": "object"
}

================
File: test/support/example.jsonld
================
{
  "@graph": [
    {
      "@id": "http://example.org/subject",
      "http://example.org/predicate": "object"
    }
  ],
  "@id": "http://example.org/subject"
}

================
File: test/support/example.n3
================
<http://example.org/subject> <http://example.org/predicate> "object" .

================
File: test/support/example.nq
================
<http://example.org/subject> <http://example.org/predicate> "object" <http://example.org/subject> .

================
File: test/support/example.nt
================
<http://example.org/subject> <http://example.org/predicate> "object" .

================
File: test/support/example.trig
================
graph <http://example.org/subject> {
    <http://example.org/subject> <http://example.org/predicate> "object" .
}

================
File: test/support/example.ttl
================
<subject> <predicate> "object" .

================
File: test/test.js
================
import { strictEqual } from 'node:assert'
import { describe, it } from 'mocha'
import fromFile from '../fromFile.js'
import * as rdfUtilsFs from '../index.js'
import toFile from '../toFile.js'
describe('rdf-utils-fs', () => {
  it('should export fromFile', () => {
    strictEqual(rdfUtilsFs.fromFile, fromFile)
  })
  it('should export toFile', () => {
    strictEqual(rdfUtilsFs.toFile, toFile)
  })
})

================
File: test/toFile.test.js
================
import { strictEqual, throws } from 'node:assert'
import { readFile } from 'node:fs/promises'
import { describe, it } from 'mocha'
import shell from 'shelljs'
import toFile from '../toFile.js'
import * as example from './support/example.js'
describe('toFile', () => {
  shell.mkdir('-p', 'tmp')
  it('should be a function', () => {
    strictEqual(typeof toFile, 'function')
  })
  it('should create a quad stream', async () => {
    const filename = 'tmp/test.nt'
    await toFile(example.defaultGraph().toStream(), filename)
    const content = (await readFile(filename)).toString().trim()
    const expected = (await readFile(new URL('support/example.nt', import.meta.url).pathname)).toString().trim()
    strictEqual(content, expected)
  })
  it('should throw an error if the file extension is unknown', () => {
    throws(() => {
      toFile(example.defaultGraph().toStream(), 'test.jpg')
    })
  })
  it('should throw an error if the media type is unknown', () => {
    throws(() => {
      toFile(example.defaultGraph().toStream(), 'test.jpg', {
        extensions: {
          jpg: 'image/jpeg'
        }
      })
    })
  })
})

================
File: toFile.js
================
import { createWriteStream } from 'node:fs'
import { extname } from 'node:path'
import { promisify } from 'node:util'
import formats from '@rdfjs/formats-common'
import { finished } from 'readable-stream'
import defaults from './defaults.js'
function toFile (stream, filename, { extensions = defaults.extensions, ...options } = {}) {
  const extension = extname(filename).split('.').pop()
  const mediaType = extensions[extension]
  if (!mediaType) {
    throw new Error(`Unknown file extension: ${extension}`)
  }
  const serializer = formats.serializers.get(mediaType)
  if (!serializer) {
    throw new Error(`No serializer available for media type: ${mediaType}`)
  }
  const output = createWriteStream(filename)
  serializer.import(stream, options).pipe(output)
  return promisify(finished)(output)
}
export default toFile
