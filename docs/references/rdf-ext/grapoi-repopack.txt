================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-09-11T12:21:23.290Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
Transmissions repo

================================================================
Repository Files
================================================================

================
File: .github/workflows/test.yaml
================
name: Test
on:
  - pull_request
  - push
jobs:
  test:
    runs-on: ubuntu-20.04
    strategy:
      matrix:
        node:
          - '18'
          - '20'
          - '21'
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node }}
      - run: npm install
      - run: npm test
      - uses: codecov/codecov-action@v3

================
File: Edge.js
================
class Edge {
  constructor ({ dataset, end, quad, start }) {
    this.dataset = dataset
    this.end = end
    this.quad = quad
    this.start = start
  }
  get term () {
    return this.quad[this.end]
  }
  get graph () {
    return this.quad.graph
  }
  get startTerm () {
    return this.quad[this.start]
  }
}
export default Edge

================
File: Factory.js
================
import grapoi from './index.js'
class Factory {
  grapoi ({ ...args } = {}) {
    if (!args.dataset && typeof this.dataset === 'function') {
      args.dataset = this.dataset()
    }
    return grapoi({ ...args, factory: this })
  }
}
Factory.exports = ['grapoi']
export default Factory

================
File: Grapoi.js
================
import { baseDataset, baseTerm } from './lib/base.js'
import { rebaseDataset } from './lib/rebase.js'
import { replaceDataset } from './lib/replace.js'
import sortByScore from './lib/sortByScore.js'
import toPathArray from './lib/toPathArray.js'
import toTerm from './lib/toTerm.js'
import toTermArray from './lib/toTermArray.js'
import Path from './Path.js'
import PathList from './PathList.js'
class Grapoi extends PathList {
  constructor ({ dataset, factory, ptrs, term, terms, graph, graphs }) {
    if (term || terms) {
      terms = terms || term
    }
    if (graph || graphs) {
      graphs = graphs || graph
    }
    if (!ptrs && terms) {
      ptrs = toPathArray(terms, { dataset, factory, graph: graphs })
    }
    super({ dataset, factory, ptrs, graphs })
  }
  _toTerm (value) {
    return toTerm(value, { factory: this.factory })
  }
  _toTermArray (values) {
    return toTermArray(values, { factory: this.factory })
  }
  addIn (predicates, subjects, callback) {
    if (typeof subjects === 'function') {
      callback = subjects
      subjects = null
    }
    if (!subjects) {
      subjects = [this.factory.blankNode()]
    }
    return super.addIn(this._toTermArray(predicates), this._toTermArray(subjects), callback)
  }
  addList (predicates, items) {
    return super.addList(this._toTermArray(predicates), this._toTermArray(items))
  }
  addOut (predicates, objects, callback) {
    if (typeof objects === 'function') {
      callback = objects
      objects = null
    }
    if (!objects) {
      objects = [this.factory.blankNode()]
    }
    return super.addOut(this._toTermArray(predicates), this._toTermArray(objects), callback)
  }
  base (base) {
    if (!base) {
      throw new Error('base parameter is required')
    }
    base = this._toTerm(base)
    for (const ptr of this.ptrs) {
      baseDataset(base, { factory: this.factory })(ptr.dataset)
    }
    return this.node(baseTerm(base, { factory: this.factory })(this.term))
  }
  best (score) {
    return this.score(score, { limit: 1 })
  }
  deleteIn (predicates, subjects) {
    return super.deleteIn(this._toTermArray(predicates), this._toTermArray(subjects))
  }
  deleteList (predicates) {
    return super.deleteList(this._toTermArray(predicates))
  }
  deleteOut (predicates, objects) {
    return super.deleteOut(this._toTermArray(predicates), this._toTermArray(objects))
  }
  hasIn (predicates, subjects) {
    return super.hasIn(this._toTermArray(predicates), this._toTermArray(subjects))
  }
  hasOut (predicates, objects) {
    return super.hasOut(this._toTermArray(predicates), this._toTermArray(objects))
  }
  in (predicates, subjects) {
    return super.in(this._toTermArray(predicates), this._toTermArray(subjects))
  }
  out (predicates, objects) {
    return super.out(this._toTermArray(predicates), this._toTermArray(objects))
  }
  node (terms = null) {
    return super.node(this._toTermArray(terms))
  }
  rebase (base) {
    if (!base) {
      throw new Error('base parameter is required')
    }
    base = this._toTerm(base)
    for (const ptr of this.ptrs) {
      rebaseDataset(ptr.term, base, { factory: this.factory })(ptr.dataset)
    }
    return this.node(base)
  }
  replace (replacement) {
    if (!replacement) {
      throw new Error('replacement parameter is required')
    }
    replacement = this._toTerm(replacement)
    for (const ptr of this.ptrs) {
      replaceDataset(ptr.term, replacement, { factory: this.factory })(ptr.dataset)
    }
    return this.node(replacement)
  }
  score (score, { limit = Infinity, offset = 0 } = {}) {
    const ptrs = sortByScore(score(this))
      .slice(offset, offset + limit)
      .map(ptr => new Path({ ...ptr, factory: this.factory }))
    return this.clone({ ptrs })
  }
}
export default Grapoi

================
File: LICENSE.md
================
MIT License

Copyright (c) 2023 Thomas Bergwinkl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: Path.js
================
import Processor from './Processor.js'
function createEdgeCallback (context, callback) {
  if (!callback) {
    return () => {}
  }
  return edge => callback(context.extend(edge))
}
class Path {
  constructor ({ dataset, edges = [], factory, graph, term }) {
    if (!dataset && edges.length === 0) {
      throw new Error('dataset or edges is required')
    }
    if (edges.length === 0 && typeof term === 'undefined') {
      throw new Error('edges or term must be given')
    }
    if (edges.length > 0 && term) {
      throw new Error('edges or term must be given')
    }
    this.dataset = dataset || edges[edges.length - 1].dataset
    this.edges = edges
    this.factory = factory
    this._graph = graph
    if (edges.length === 0) {
      this._term = term
    }
  }
  get edge () {
    return this.edges[this.edges.length - 1]
  }
  get graph () {
    if (typeof this._graph === 'object') {
      return this._graph
    }
    return this.edge && this.edge.graph
  }
  get length () {
    if (this._term !== undefined) {
      return 1
    }
    return this.edges.length + 1
  }
  get startTerm () {
    return this._term || this.edges[0].startTerm
  }
  get term () {
    if (this._term !== undefined) {
      return this._term
    }
    return this.edge.term
  }
  get value () {
    const term = this.term
    return term === null ? undefined : term.value
  }
  addIn (predicates, subjects, callback) {
    return Processor.add({
      ptr: this,
      start: 'object',
      end: 'subject',
      subjects,
      predicates,
      graphs: [this.graph || this.factory.defaultGraph()],
      callback: createEdgeCallback(this, callback)
    })
  }
  addList (predicates, items) {
    return Processor.addList({
      ptr: this,
      predicates,
      graphs: [this.graph || this.factory.defaultGraph()],
      items
    })
  }
  addOut (predicates, objects, callback) {
    return Processor.add({
      ptr: this,
      start: 'subject',
      end: 'object',
      predicates,
      objects,
      graphs: [this.graph || this.factory.defaultGraph()],
      callback: createEdgeCallback(this, callback)
    })
  }
  deleteIn (predicates, subjects) {
    return Processor.delete({
      ptr: this,
      start: 'object',
      subjects,
      predicates
    })
  }
  deleteList (predicates) {
    return Processor.deleteList({
      ptr: this,
      predicates
    })
  }
  deleteOut (predicates, objects) {
    return Processor.delete({
      ptr: this,
      start: 'subject',
      predicates,
      objects
    })
  }
  execute ({ operation, quantifier, start, end, subjects, predicates, objects, graphs, items, callback }) {
    return Processor.execute({
      ptr: this,
      operation,
      quantifier,
      start,
      end,
      subjects,
      predicates,
      objects,
      graphs,
      items,
      callback
    })
  }
  extend (edge) {
    return new this.constructor({
      dataset: this.dataset,
      edges: [...this.edges, edge],
      factory: this.factory,
      graph: this._graph
    })
  }
  hasIn (predicates, subjects) {
    return Processor.traverse({
      ptr: this,
      start: 'object',
      end: 'object',
      subjects,
      predicates,
      graphs: [this.graph]
    })
  }
  hasOut (predicates, objects) {
    return Processor.traverse({
      ptr: this,
      start: 'subject',
      end: 'subject',
      predicates,
      objects,
      graphs: [this.graph]
    })
  }
  in (predicates, subjects) {
    return Processor.traverse({
      ptr: this,
      start: 'object',
      end: 'subject',
      subjects,
      predicates,
      graphs: [this.graph]
    })
  }
  isAny () {
    return !this.term
  }
  isList () {
    return Processor.isList({ ptr: this })
  }
  list () {
    return Processor.list({ ptr: this })
  }
  nodes () {
    const path = this
    const at = index => {
      if (this._term !== undefined) {
        return {
          dataset: this.dataset,
          term: this._term
        }
      }
      if (this.edges.length > index) {
        return {
          dataset: this.edges[index].dataset,
          term: this.edges[index].startTerm
        }
      }
      if (this.edges.length === index) {
        return {
          dataset: this.edges[index - 1].dataset,
          term: this.edges[index - 1].term
        }
      }
    }
    return {
      * [Symbol.iterator] () {
        for (let index = 0; index < path.length; index++) {
          yield at(index)
        }
      }
    }
  }
  out (predicates, objects) {
    return Processor.traverse({
      ptr: this,
      predicates,
      objects,
      graphs: [this.graph]
    })
  }
  quads () {
    const path = this
    return {
      * [Symbol.iterator] () {
        for (const edge of path.edges) {
          yield edge.quad
        }
      }
    }
  }
  trim () {
    return new this.constructor({
      dataset: this.dataset,
      factory: this.factory,
      graph: this.graph,
      term: this.term
    })
  }
}
export default Path

================
File: PathList.js
================
import TermSet from '@rdfjs/term-set'
import ptrIsEqual from './lib/ptrIsEqual.js'
import Path from './Path.js'
function createExtendCallback (ptrList, callback) {
  if (!callback) {
    return () => {}
  }
  return ptr => {
    return callback(new ptrList.constructor({
      factory: ptrList.factory,
      ptrs: [ptr]
    }))
  }
}
class PathList {
  constructor ({ dataset, factory, ptrs, terms, graphs }) {
    this.factory = factory
    if (ptrs) {
      this.ptrs = [...ptrs]
    } else {
      this.ptrs = []
      for (const term of (terms || [null])) {
        for (const graph of (graphs || [null])) {
          this.ptrs.push(new Path({ dataset, factory, graph, term }))
        }
      }
    }
  }
  get dataset () {
    const datasets = new Set(this.datasets)
    if (datasets.size !== 1) {
      return null
    }
    return datasets[Symbol.iterator]().next().value
  }
  get datasets () {
    return this.ptrs.map(ptr => ptr.dataset)
  }
  get term () {
    const terms = new TermSet(this.terms)
    if (terms.size !== 1) {
      return undefined
    }
    return terms[Symbol.iterator]().next().value
  }
  get terms () {
    return this.ptrs.map(ptr => ptr.term)
  }
  get value () {
    const term = this.term
    return (term === undefined || term === null) ? undefined : term.value
  }
  get values () {
    return this.ptrs.map(ptr => ptr.value)
  }
  addIn (predicates, subjects, callback) {
    const extendCallback = createExtendCallback(this, callback)
    for (const ptr of this.ptrs) {
      ptr.addIn(predicates, subjects, extendCallback)
    }
    return this
  }
  addList (predicates, items) {
    if (this.isAny()) {
      throw new Error('can\'t attach a list to an any ptr')
    }
    for (const ptr of this.ptrs) {
      ptr.addList(predicates, items)
    }
    return this
  }
  addOut (predicates, objects, callback) {
    const extendCallback = createExtendCallback(this, callback)
    for (const ptr of this.ptrs) {
      ptr.addOut(predicates, objects, extendCallback)
    }
    return this
  }
  clone (args) {
    return new this.constructor({ factory: this.factory, ptrs: this.ptrs, ...args })
  }
  deleteIn (predicates, subjects) {
    for (const ptr of this.ptrs) {
      ptr.deleteIn(predicates, subjects)
    }
    return this
  }
  deleteList (predicates) {
    for (const ptr of this.ptrs) {
      ptr.deleteList(predicates)
    }
    return this
  }
  deleteOut (predicates, objects) {
    for (const ptr of this.ptrs) {
      ptr.deleteOut(predicates, objects)
    }
    return this
  }
  distinct () {
    const ptrs = this.ptrs.reduce((unique, ptr) => {
      if (!unique.some(uPtr => ptrIsEqual(uPtr, ptr))) {
        unique.push(ptr.trim())
      }
      return unique
    }, [])
    return this.clone({ ptrs })
  }
  execute (instruction) {
    return this.clone({ ptrs: this.ptrs.flatMap(ptr => ptr.execute(instruction)) })
  }
  executeAll (instructions) {
    let output = this
    for (const instruction of instructions) {
      output = output.execute(instruction)
    }
    return output
  }
  filter (callback) {
    return this.clone({ ptrs: [...this].filter(callback).map(ptr => ptr.ptrs[0]) })
  }
  hasIn (predicates, subjects) {
    return this.clone({ ptrs: this.ptrs.flatMap(ptr => ptr.hasIn(predicates, subjects)) })
  }
  hasOut (predicates, objects) {
    return this.clone({ ptrs: this.ptrs.flatMap(ptr => ptr.hasOut(predicates, objects)) })
  }
  in (predicates, subjects) {
    return this.clone({ ptrs: this.ptrs.flatMap(ptr => ptr.in(predicates, subjects)) })
  }
  isAny () {
    return this.ptrs.length > 0 && this.ptrs.some(ptr => ptr.isAny())
  }
  isList () {
    if (this.ptrs.length !== 1) {
      return false
    }
    return this.ptrs[0].isList()
  }
  list () {
    if (!this.isList()) {
      return undefined
    }
    const iterator = this.ptrs[0].list()[Symbol.iterator]()
    const next = () => {
      const { done, value } = iterator.next()
      if (done) {
        return { done: true }
      }
      return { done: false, value: this.clone({ ptrs: [value] }) }
    }
    return {
      [Symbol.iterator]: () => {
        return { next }
      }
    }
  }
  map (callback) {
    return [...this].map(callback)
  }
  node (terms) {
    const ptrs = [...terms].map(term => new Path({ dataset: this.dataset, factory: this.factory, term }))
    return this.clone({ ptrs })
  }
  out (predicates, objects) {
    return this.clone({ ptrs: this.ptrs.flatMap(ptr => ptr.out(predicates, objects)) })
  }
  quads () {
    const pathList = this
    return {
      * [Symbol.iterator] () {
        for (const path of pathList.ptrs) {
          for (const edge of path.edges) {
            yield edge.quad
          }
        }
      }
    }
  }
  trim () {
    return this.clone({
      ptrs: this.ptrs.map(ptr => ptr.trim())
    })
  }
  * [Symbol.iterator] () {
    for (const ptr of this.ptrs) {
      yield this.clone({ ptrs: [ptr] })
    }
  }
}
export default PathList

================
File: Processor.js
================
import TermSet from '@rdfjs/term-set'
import Edge from './Edge.js'
import * as ns from './lib/namespaces.js'
class Processor {
  static add ({ ptr, start, end, subjects = [null], predicates = [null], objects = [null], graphs, callback } = {}) {
    if (!ptr.factory) {
      throw new Error('add operation requires a factory')
    }
    let edgeCallback = () => {}
    if (callback) {
      edgeCallback = quad => {
        callback(new Edge({ dataset: ptr.dataset, start, end, quad }))
      }
    }
    for (const subject of subjects) {
      for (const predicate of predicates) {
        for (const object of objects) {
          for (const graph of graphs) {
            const pattern = { subject, predicate, object, graph }
            pattern[start] = ptr.term
            const quad = ptr.factory.quad(
              pattern.subject,
              pattern.predicate,
              pattern.object,
              pattern.graph
            )
            ptr.dataset.add(quad)
            edgeCallback(quad)
          }
        }
      }
    }
    return ptr
  }
  static addList ({ ptr, predicates, items, graphs }) {
    if (ptr.isAny()) {
      throw new Error('can\'t attach a list to an any ptr')
    }
    for (const predicate of predicates) {
      for (const graph of graphs) {
        const nodes = items.map(() => ptr.factory.blankNode())
        ptr.dataset.add(ptr.factory.quad(ptr.term, predicate, nodes[0] || ns.rdf.nil, graph))
        for (let index = 0; index < nodes.length; index++) {
          ptr.dataset.add(ptr.factory.quad(nodes[index], ns.rdf.first, items[index], graph))
          ptr.dataset.add(ptr.factory.quad(nodes[index], ns.rdf.rest, nodes[index + 1] || ns.rdf.nil, graph))
        }
      }
    }
    return ptr
  }
  static delete ({
    ptr,
    start,
    subjects = [null],
    predicates = [null],
    objects = [null]
  }) {
    for (const subject of subjects) {
      for (const predicate of predicates) {
        for (const object of objects) {
          const pattern = { subject, predicate, object }
          pattern[start] = ptr.term
          const matches = ptr.dataset.match(pattern.subject, pattern.predicate, pattern.object)
          for (const quad of matches) {
            ptr.dataset.delete(quad)
          }
        }
      }
    }
    return ptr
  }
  static deleteList ({ ptr, predicates }) {
    const toDelete = []
    for (const predicate of predicates) {
      for (const quad of ptr.dataset.match(ptr.term, predicate)) {
        let link = quad.object
        toDelete.push(quad)
        while (!ns.rdf.nil.equals(link)) {
          link = toDelete[toDelete.length - 1].object
          const matches = ptr.dataset.match(link)
          if (matches.size === 0) {
            break
          }
          for (const quad of matches) {
            toDelete.push(quad)
          }
        }
      }
    }
    for (const quad of toDelete) {
      ptr.dataset.delete(quad)
    }
    return ptr
  }
  static execute ({
    ptr,
    operation = 'traverse',
    quantifier,
    start,
    end,
    subjects,
    predicates,
    objects,
    graphs,
    items,
    callback
  } = {}) {
    if (operation === 'add') {
      return Processor.add({ ptr, start, end, subjects, predicates, objects, graphs, callback })
    }
    if (operation === 'addList') {
      return Processor.addList({ ptr, predicates, items, graphs })
    }
    if (operation === 'delete') {
      return Processor.delete({ ptr, start, subjects, predicates, objects })
    }
    if (operation === 'deleteList') {
      return Processor.deleteList({ ptr, predicates })
    }
    if (operation === 'isList') {
      return Processor.isList({ ptr })
    }
    if (operation === 'list') {
      return Processor.list({ ptr })
    }
    if (operation === 'traverse') {
      return Processor.traverse({ ptr, quantifier, start, end, subjects, predicates, objects, graphs })
    }
    throw new Error(`unknown operation ${operation}`)
  }
  static isList ({ ptr }) {
    if (ptr.isAny()) {
      return false
    }
    if (ns.rdf.nil.equals(ptr.term)) {
      return true
    }
    const item = Processor.traverse({ ptr, predicates: [ns.rdf.first] })
    if (item.length === 1) {
      return true
    }
    return false
  }
  static list ({ ptr }) {
    if (!ptr.isList()) {
      return undefined
    }
    return {
      * [Symbol.iterator] () {
        while (ptr && !ptr.term.equals(ns.rdf.nil)) {
          const value = ptr.out([ns.rdf.first])
          if (value.length !== 1) {
            throw new Error(`Invalid list: rdf:first count not equals one on ${ptr.value}`)
          }
          const rest = ptr.out([ns.rdf.rest])
          if (rest.length !== 1) {
            throw new Error(`Invalid list: rdf:rest count not equals one on ${ptr.value}`)
          }
          yield value[0]
          ptr = rest[0]
        }
      }
    }
  }
  static traverse ({
    ptr,
    quantifier = 'one',
    start = 'subject',
    end = 'object',
    subjects = [null],
    predicates = [null],
    objects = [null],
    graphs = [null],
    callback
  }) {
    if (quantifier === 'one') {
      return Processor.traverseOne({ ptr, start, end, subjects, predicates, objects, graphs, callback })
    }
    if (quantifier === 'oneOrMore') {
      const ptrs = Processor.traverse({ ptr, end, start, subjects, predicates, objects, graphs, callback })
      return Processor.traverseMore({ ptrs, end, start, subjects, predicates, objects, graphs, callback })
    }
    if (quantifier === 'zeroOrMore') {
      return Processor.traverseMore({ ptrs: [ptr], end, start, subjects, predicates, objects, graphs, callback })
    }
    if (quantifier === 'zeroOrOne') {
      return [ptr, ...Processor.traverse({ ptr, end, start, subjects, predicates, objects, graphs, callback })]
    }
    throw new Error(`unknown quantifier ${quantifier}`)
  }
  static traverseMore ({ ptrs, end, start, subjects, predicates, objects, graphs, callback } = {}) {
    let result = [...ptrs]
    let current
    let last
    do {
      current = []
      for (const ptr of ptrs) {
        current = [
          ...current,
          ...Processor.traverseOne({ ptr, end, start, subjects, predicates, objects, graphs, callback })
        ]
      }
      if (last) {
        current = current.filter(ptr => !last.has(ptr.term))
      }
      ptrs = current
      result = [...result, ...current]
      last = new TermSet(result.map(ptr => ptr.term))
    } while (current.length > 0)
    return result
  }
  static traverseOne ({ ptr, start, end, subjects, predicates, objects, graphs, callback = (edge, ptr) => ptr.extend(edge) } = {}) {
    const results = []
    for (const subject of subjects) {
      for (const predicate of predicates) {
        for (const object of objects) {
          for (const graph of graphs) {
            const pattern = { subject, predicate, object, graph }
            pattern[start] = ptr.term
            for (const quad of ptr.dataset.match(pattern.subject, pattern.predicate, pattern.object, pattern.graph)) {
              results.push(callback(new Edge({ dataset: ptr.dataset, end, quad, start }), ptr))
            }
          }
        }
      }
    }
    return results
  }
}
export default Processor

================
File: README.md
================
# grapoi

[![build status](https://img.shields.io/github/actions/workflow/status/rdf-ext/grapoi/test.yaml?branch=master)](https://github.com/rdf-ext/grapoi/actions/workflows/test.yaml)
[![npm version](https://img.shields.io/npm/v/grapoi.svg)](https://www.npmjs.com/package/grapoi)

Grapoi is a JavaScript graph traversal library inspired by [Gremlin](https://tinkerpop.apache.org/gremlin.html).
It allows querying [RDF/JS Datasets](https://rdf.js.org/dataset-spec/) readable and intuitive way.
Grapoi makes processing RDF data in JavaScript fun again.

The main purpose of Grapoi is to traverse and filter through datasets with ease.
Most methods will return new object instances that refer back to the result terms after being processed by their respective functions.

Additionally, Grapoi keeps track of all quads traversed from the start term, making it possible for you to keep track of how each result was found during the query process if needed - thus providing extra flexibility when dealing with complex datasets where multiple paths might lead towards desired results.

## Install

```bash
npm install grapoi --save
```

## Usage

### Query Data

This example shows how to query an RDF/JS Dataset based on the [housemd](https://www.npmjs.com/package/housemd) dataset.
It covers how to use the methods `.out()` and `.in()` to traverse outwards or inwards. 
`.trim()` can be used to remove the tail of the traversing history, which is not of interest.
Once this is done, only those quads that are relevant can be listed with the `.quads()` method. 
A unique list of terms can be created with `.distinct()`.

```javascript
import grapoi from 'grapoi'
import housemd from 'housemd'
import rdf from 'rdf-ext'

const ns = {
  house: rdf.namespace('https://housemd.rdf-ext.org/'),
  rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
  schema: rdf.namespace('http://schema.org/'),
  xsd: rdf.namespace('http://www.w3.org/2001/XMLSchema#')
}

const dataset = rdf.dataset(housemd({ factory: rdf }))

const people = grapoi({ dataset, term: ns.house('person/') })

console.log('people in the house dataset:')

for (const quad of people.out(ns.schema.hasPart).quads()) {
  console.log(`\t${quad.object.value}`)
}

const house = grapoi({ dataset, factory: rdf, term: 'Gregory' }).in().trim()

console.log('properties of the guy named Gregory:')

for (const quad of house.out().quads()) {
  console.log(`\t${quad.predicate.value}: ${quad.object.value}`)
}

const address = house
  .out(ns.schema.homeLocation)
  .out(ns.schema.address)

console.log('address of the guy named Gregory:')

for (const quad of address.trim().out().quads()) {
  console.log(`\t${quad.predicate.value}: ${quad.object.value}`)
}

const nationalities = house
  .out(ns.schema.knows)
  .out(ns.schema.nationality)
  .distinct()

console.log('nationalities of all known people:')

for (const value of nationalities.values) {
  console.log(`\t${value}`)
}
```

### Create Data

This example shows how to create data with Grapoi.
The starting point is the term given in the `grapoi` factory function.
Quads are added `.addOut()` from subject to object direction.
Nested structures can be created in the callback, which is called with a `grapoi` instance referring to the new object.

```javascript
import grapoi from 'grapoi'
import rdf from 'rdf-ext'

const ns = {
  ex: rdf.namespace('https://example.org/'),
  rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
  schema: rdf.namespace('http://schema.org/'),
  xsd: rdf.namespace('http://www.w3.org/2001/XMLSchema#')
}

const dataset = rdf.dataset()

const person = grapoi({ dataset, factory: rdf, term: ns.ex.address })

person.addOut(ns.schema.homeLocation, location => {
  location.addOut(ns.schema.address, address => {
    address.addOut(ns.schema.addressLocality, 'Plainsboro Township')
    address.addOut(ns.schema.addressRegion, 'NJ')
    address.addOut(ns.schema.postalCode, '08536')
    address.addOut(ns.schema.streetAddress, '221B Baker Street')
  })
})

for (const quad of dataset) {
  console.log(`${quad.subject.value} - ${quad.predicate.value} - ${quad.object.value}`)
}
```

================
File: examples/create-data.js
================
import namespace from '@rdfjs/namespace'
import grapoi from '../index.js'
import rdf from '../test/support/factory.js'
const ns = {
  ex: namespace('https://example.org/'),
  rdf: namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
  schema: namespace('http://schema.org/'),
  xsd: namespace('http://www.w3.org/2001/XMLSchema#')
}
const dataset = rdf.dataset()
const person = grapoi({ dataset, factory: rdf, term: ns.ex.address })
person.addOut(ns.schema.homeLocation, location => {
  location.addOut(ns.schema.address, address => {
    address.addOut(ns.schema.addressLocality, 'Plainsboro Township')
    address.addOut(ns.schema.addressRegion, 'NJ')
    address.addOut(ns.schema.postalCode, '08536')
    address.addOut(ns.schema.streetAddress, '221B Baker Street')
  })
})
for (const quad of dataset) {
  console.log(`${quad.subject.value} - ${quad.predicate.value} - ${quad.object.value}`)
}

================
File: examples/explore-house.js
================
import namespace from '@rdfjs/namespace'
import housemd from 'housemd'
import grapoi from '../index.js'
import rdf from '../test/support/factory.js'
const ns = {
  house: namespace('https://housemd.rdf-ext.org/'),
  rdf: namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
  schema: namespace('http://schema.org/'),
  xsd: namespace('http://www.w3.org/2001/XMLSchema#')
}
const dataset = rdf.dataset(housemd({ factory: rdf }))
const people = grapoi({ dataset, term: ns.house('person/') })
console.log('people in the house dataset:')
for (const quad of people.out(ns.schema.hasPart).quads()) {
  console.log(`\t${quad.object.value}`)
}
const house = grapoi({ dataset, factory: rdf, term: 'Gregory' }).in().trim()
console.log('properties of the guy named Gregory:')
for (const quad of house.out().quads()) {
  console.log(`\t${quad.predicate.value}: ${quad.object.value}`)
}
const address = house
  .out(ns.schema.homeLocation)
  .out(ns.schema.address)
console.log('address of the guy named Gregory:')
for (const quad of address.trim().out().quads()) {
  console.log(`\t${quad.predicate.value}: ${quad.object.value}`)
}
const nationalities = house
  .out(ns.schema.knows)
  .out(ns.schema.nationality)
  .distinct()
console.log('nationalities of all known people:')
for (const value of nationalities.values) {
  console.log(`\t${value}`)
}

================
File: index.js
================
import Edge from './Edge.js'
import Grapoi from './Grapoi.js'
import Path from './Path.js'
import PathList from './PathList.js'
function grapoi (args) {
  return new Grapoi(args)
}
export {
  grapoi as default,
  Edge,
  Grapoi,
  Path,
  PathList
}

================
File: lib/base.js
================
function baseDataset (newBaseTerm, { factory }) {
  const base = baseQuad(newBaseTerm, { factory })
  return dataset => {
    for (const quad of [...dataset]) {
      const newQuad = base(quad)
      if (newQuad !== quad) {
        dataset.delete(quad)
        dataset.add(newQuad)
      }
    }
  }
}
function baseQuad (newBaseTerm, { factory }) {
  const base = baseTerm(newBaseTerm, { factory })
  return quad => {
    const subject = base(quad.subject)
    const predicate = base(quad.predicate)
    const object = base(quad.object)
    if (subject === quad.subject && predicate === quad.predicate && object === quad.object) {
      return quad
    }
    return factory.quad(subject, predicate, object, quad.graph)
  }
}
function baseTerm (newBaseTerm, { factory }) {
  return term => {
    if (term.termType !== 'NamedNode') {
      return term
    }
    if (/^[a-z]+:\/\//.test(term.value)) {
      return term
    }
    return factory.namedNode(new URL(term.value, newBaseTerm.value).toString())
  }
}
export {
  baseDataset,
  baseQuad,
  baseTerm
}

================
File: lib/namespaces.js
================
import namespace from '@rdfjs/namespace'
const xsd = namespace('http://www.w3.org/2001/XMLSchema#')
const rdfns = namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
const rdfs = namespace('http://www.w3.org/2000/01/rdf-schema#')
export {
  xsd,
  rdfns as rdf,
  rdfs
}

================
File: lib/ptrIsEqual.js
================
import termIsEqual from './termIsEqual.js'
function ptrIsEqual (a, b) {
  if (a.dataset !== b.dataset) {
    return false
  }
  if (!termIsEqual(a.graph, b.graph)) {
    return false
  }
  if (!termIsEqual(a.term, b.term)) {
    return false
  }
  return true
}
export default ptrIsEqual

================
File: lib/rebase.js
================
const isIriRegExp = /^[a-z][a-z0-9+.-]*:/
function rebaseDataset (oldTerm, newTerm, { factory }) {
  const rebase = rebaseQuad(oldTerm, newTerm, { factory })
  return dataset => {
    for (const quad of [...dataset]) {
      const newQuad = rebase(quad)
      if (newQuad !== quad) {
        dataset.delete(quad)
        dataset.add(newQuad)
      }
    }
  }
}
function rebaseQuad (oldTerm, newTerm, { factory }) {
  const rebase = rebaseTerm(oldTerm, newTerm, { factory })
  return quad => {
    const subject = rebase(quad.subject)
    const predicate = rebase(quad.predicate)
    const object = rebase(quad.object)
    if (subject === quad.subject && predicate === quad.predicate && object === quad.object) {
      return quad
    }
    return factory.quad(subject, predicate, object, quad.graph)
  }
}
function rebaseTerm (oldTerm, newTerm, { factory }) {
  return term => {
    if (term.termType !== 'NamedNode') {
      return term
    }
    if (!term.value.startsWith(oldTerm.value)) {
      return term
    }
    if (isIriRegExp.test(term.value) !== isIriRegExp.test(oldTerm.value)) {
      return term
    }
    return factory.namedNode(newTerm.value + term.value.slice(oldTerm.value.length))
  }
}
export {
  rebaseDataset,
  rebaseQuad,
  rebaseTerm
}

================
File: lib/replace.js
================
function replaceDataset (oldTerm, newTerm, { factory }) {
  const rebase = replaceQuad(oldTerm, newTerm, { factory })
  return dataset => {
    const quads = [
      ...[...dataset.match(oldTerm)],
      ...[...dataset.match(null, oldTerm)],
      ...[...dataset.match(null, null, oldTerm)]
    ]
    for (const quad of quads) {
      const newQuad = rebase(quad)
      if (newQuad !== quad) {
        dataset.delete(quad)
        dataset.add(newQuad)
      }
    }
  }
}
function replaceQuad (oldTerm, newTerm, { factory }) {
  const replace = replaceTerm(oldTerm, newTerm)
  return quad => {
    const subject = replace(quad.subject)
    const predicate = replace(quad.predicate)
    const object = replace(quad.object)
    if (subject === quad.subject && predicate === quad.predicate && object === quad.object) {
      return quad
    }
    return factory.quad(subject, predicate, object, quad.graph)
  }
}
function replaceTerm (oldTerm, newTerm) {
  return term => {
    if (term.equals(oldTerm)) {
      return newTerm
    }
    return term
  }
}
export {
  replaceDataset,
  replaceQuad,
  replaceTerm
}

================
File: lib/sortByScore.js
================
function sortByScore (results) {
  return results.slice().sort((a, b) => {
    const diff = b.score - a.score
    if (diff !== 0) {
      return diff
    }
    return a.term.value.localeCompare(b.term.value)
  })
}
export default sortByScore

================
File: lib/termIsEqual.js
================
function termIsEqual (a, b) {
  if (a) {
    return a.equals(b)
  }
  return a === b
}
export default termIsEqual

================
File: lib/toPath.js
================
import Path from '../Path.js'
import toTerm from './toTerm.js'
function isPtr (value) {
  return typeof value.term === 'object' && typeof value.dataset === 'object'
}
function isPath (value) {
  return value instanceof Path
}
function toPath (value, { dataset, factory, graph }) {
  if (value === null) {
    return null
  }
  if (value === undefined) {
    return undefined
  }
  if (isPath(value)) {
    return value
  }
  if (isPtr(value)) {
    return new Path({
      dataset: value.dataset,
      graph: value.graph,
      term: value.term,
      factory: value.factory || factory
    })
  }
  return new Path({
    dataset,
    graph,
    term: toTerm(value, { factory }),
    factory
  })
}
export default toPath

================
File: lib/toPathArray.js
================
import toPath from './toPath.js'
import toTermArray from './toTermArray.js'
function toPathArray (values, { dataset, factory, graph }) {
  try {
    values = [toPath(values, { dataset, factory, graph })]
  } catch (err) {}
  if (values[Symbol.iterator]) {
    values = [...values]
  }
  return values.flatMap(value => {
    return toTermArray(graph, { factory }).flatMap(graph => {
      return toPath(value, { dataset, factory, graph })
    })
  })
}
export default toPathArray

================
File: lib/toTerm.js
================
function toTerm (value, { factory }) {
  if (value === null) {
    return null
  }
  if (value === undefined) {
    return undefined
  }
  if (typeof value === 'string') {
    return factory.literal(value)
  }
  if (value.constructor.name === 'URL') {
    return factory.namedNode(value.toString())
  }
  if (value.termType) {
    return value
  }
  const term = value.term
  if (term !== undefined) {
    return term
  }
  throw new Error(`can't convert ${value.toString()} to a Term object`)
}
export default toTerm

================
File: lib/toTermArray.js
================
import toTerm from './toTerm.js'
function toTermArray (values, { factory }) {
  try {
    values = [toTerm(values, { factory })]
  } catch (err) {}
  if (values[Symbol.iterator]) {
    values = [...values]
  }
  values = values.map(value => toTerm(value, { factory }))
  return values
}
export default toTermArray

================
File: package.json
================
{
  "name": "grapoi",
  "version": "1.1.1",
  "description": "Universal RDF/JS graph traverser",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "stricter-standard && c8 --reporter=lcov --reporter=text-summary mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/rdf-ext/grapoi.git"
  },
  "keywords": [
    "edge",
    "graph",
    "node",
    "path",
    "rdf",
    "rdfjs",
    "traverse"
  ],
  "author": "Thomas Bergwinkl <bergi@axolotlfarm.org> (https://www.bergnet.org/people/bergi/card#me)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/rdf-ext/grapoi/issues"
  },
  "homepage": "https://github.com/rdf-ext/grapoi",
  "dependencies": {
    "@rdfjs/namespace": "^2.0.0",
    "@rdfjs/term-set": "^2.0.0"
  },
  "devDependencies": {
    "@rdfjs/data-model": "^2.0.0",
    "@rdfjs/dataset": "^2.0.0",
    "@rdfjs/environment": "^0.1.1",
    "@rdfjs/term-map": "^2.0.0",
    "c8": "^7.11.0",
    "housemd": "^0.1.0",
    "mocha": "^9.2.0",
    "rdf-test": "^0.1.0",
    "stricter-standard": "^0.2.0"
  }
}

================
File: test/Edge.test.js
================
import { strictEqual } from 'assert'
import { describe, it } from 'mocha'
import Edge from '../Edge.js'
import factory from './support/factory.js'
import * as ns from './support/namespaces.js'
describe('Edge', () => {
  it('should be a constructor', () => {
    strictEqual(typeof Edge, 'function')
  })
  it('should assign the given dataset to .dataset', () => {
    const dataset = factory.dataset()
    const edge = new Edge({ dataset })
    strictEqual(edge.dataset, dataset)
  })
  it('should assign the given end to .end', () => {
    const end = 'subject'
    const edge = new Edge({ end })
    strictEqual(edge.end, end)
  })
  it('should assign the given quad to .quad', () => {
    const quad = factory.quad(ns.ex.subject, ns.ex.predicate, ns.ex.object)
    const edge = new Edge({ quad })
    strictEqual(edge.quad, quad)
  })
  it('should assign the given end to .start', () => {
    const start = 'subject'
    const edge = new Edge({ start })
    strictEqual(edge.start, start)
  })
  describe('.term', () => {
    it('should be the term at the end position of the given quad', () => {
      const quad = factory.quad(ns.ex.subject, ns.ex.predicate, ns.ex.object)
      const edge = new Edge({ end: 'object', quad })
      strictEqual(ns.ex.object.equals(edge.term), true)
    })
  })
  describe('.graph', () => {
    it('should be the graph term of the given quad', () => {
      const quad = factory.quad(ns.ex.subject, ns.ex.predicate, ns.ex.object, ns.ex.graph)
      const edge = new Edge({ quad })
      strictEqual(ns.ex.graph.equals(edge.graph), true)
    })
  })
  describe('.startTerm', () => {
    it('should be the term at the start position of the given quad', () => {
      const quad = factory.quad(ns.ex.subject, ns.ex.predicate, ns.ex.object)
      const edge = new Edge({ quad, start: 'subject' })
      strictEqual(ns.ex.subject.equals(edge.startTerm), true)
    })
  })
})

================
File: test/Grapoi.test.js
================
import { notStrictEqual, strictEqual, throws } from 'assert'
import { describe, it } from 'mocha'
import { datasetEqual } from 'rdf-test/assert.js'
import Grapoi from '../Grapoi.js'
import Path from '../Path.js'
import datasets from './support/datasets.multi.js'
import factory from './support/factory.js'
import { grapoiEqual } from './support/toJSON.js'
describe('Grapoi', () => {
  it('should be a constructor', () => {
    strictEqual(typeof Grapoi, 'function')
  })
  it('should assign the given factory', () => {
    const dataset = factory.dataset()
    const nodeList = new Grapoi({ dataset, factory })
    strictEqual(nodeList.factory, factory)
  })
  it('should use an any Path ptr if no ptrs are given', () => {
    const dataset = factory.dataset()
    const nodeList = new Grapoi({ dataset })
    strictEqual(nodeList.ptrs.length, 1)
    strictEqual(nodeList.ptrs[0] instanceof Path, true)
    strictEqual(nodeList.ptrs[0].term, null)
  })
  it('should use the given ptrs', () => {
    const { ptrs } = datasets.constructorPtrs()
    const grapoi = new Grapoi({ ptrs })
    strictEqual(grapoi.ptrs.length, ptrs.length)
    for (let index = 0; index < ptrs.length; index++) {
      strictEqual(grapoi.ptrs[index], ptrs[index])
    }
  })
  it('should create a Path ptr for the given term', () => {
    const { dataset, terms } = datasets.default()
    const term = terms[0]
    const grapoi = new Grapoi({ dataset, term })
    strictEqual(grapoi.ptrs.length, 1)
    strictEqual(grapoi.ptrs[0] instanceof Path, true)
    strictEqual(grapoi.ptrs[0].term.equals(term), true)
  })
  it('should create a Path ptr for each of the given terms', () => {
    const { dataset, terms } = datasets.default()
    const grapoi = new Grapoi({ dataset, terms })
    strictEqual(grapoi.ptrs.length, terms.length)
    for (let index = 0; index < terms.length; index++) {
      strictEqual(grapoi.ptrs[index] instanceof Path, true)
      strictEqual(grapoi.ptrs[index].term.equals(terms[index]), true)
    }
  })
  it('should create a Path ptr for the given term and graph', () => {
    const { dataset, graphs, terms } = datasets.constructorGraphs()
    const graph = graphs[0]
    const term = terms[0]
    const grapoi = new Grapoi({ dataset, graph, term })
    strictEqual(grapoi.ptrs.length, 1)
    strictEqual(grapoi.ptrs[0].term.equals(term), true)
    strictEqual(grapoi.ptrs[0].graph.equals(graph), true)
  })
  it('should create a Path ptr for each of the given terms and graphs', () => {
    const { dataset, graphs, terms } = datasets.constructorGraphs()
    const grapoi = new Grapoi({ dataset, graphs, terms })
    strictEqual(grapoi.ptrs.length, terms.length * graphs.length)
    for (let index = 0; index < terms.length * graphs.length; index++) {
      strictEqual(grapoi.ptrs[index].term.equals(terms[Math.floor(index / 2)]), true)
      strictEqual(grapoi.ptrs[index].graph.equals(graphs[index % 2]), true)
    }
  })
  it('should create a Path ptr for each of the given terms with the given factory', () => {
    const { dataset, terms } = datasets.default()
    const grapoi = new Grapoi({ dataset, factory, terms })
    strictEqual(grapoi.ptrs.length, terms.length)
    for (let index = 0; index < terms.length; index++) {
      strictEqual(grapoi.ptrs[index].factory, factory)
    }
  })
  it('should prioritize ptrs over terms', () => {
    const { dataset, ptrList, terms } = datasets.constructorPtrsVsTerms()
    const result = new Grapoi({ dataset, factory, ptrs: ptrList.ptrs, terms })
    grapoiEqual(result, ptrList)
  })
  describe('.addIn', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.addIn, 'function')
    })
    it('should return itself', () => {
      const { grapoi, objects, predicates } = datasets.addIn()
      const result = grapoi.addIn(predicates, objects)
      strictEqual(result, grapoi)
    })
    it('should add quads for the given predicates and blank node if no subject is given', () => {
      const { expectedQuads, grapoi, predicates } = datasets.addInNoSubject()
      grapoi.addIn(predicates)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should add quads for the given predicates and subjects', () => {
      const { expectedQuads, grapoi, predicates, subjects } = datasets.addIn()
      grapoi.addIn(predicates, subjects)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should add quads for the given predicates, subjects, and graphs', () => {
      const { expectedQuads, grapoi, predicates, subjects } = datasets.addInGraphs()
      grapoi.addIn(predicates, subjects)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should call the callback function with a grapoi object for the new path', () => {
      const result = []
      const { expectedGrapois, grapoi, predicates, subjects } = datasets.addInPath()
      grapoi.addIn(predicates, subjects, item => result.push(item))
      grapoiEqual(result, expectedGrapois)
    })
    it('should call the callback function as second argument with a grapoi object for the new path', () => {
      const result = []
      const { expectedGrapois, grapoi, predicates } = datasets.addInNoSubject()
      grapoi.addIn(predicates, item => result.push(item))
      grapoiEqual(result, expectedGrapois)
    })
  })
  describe('.addList', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.addList, 'function')
    })
    it('should return itself', () => {
      const { grapoi, predicates, items } = datasets.addList()
      const result = grapoi.addList(predicates, items)
      strictEqual(result, grapoi)
    })
    it('should create an empty list if an empty item list is given', () => {
      const { expectedQuads, grapoi, predicates, items } = datasets.addListEmpty()
      grapoi.addList(predicates, items)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should add the given items to the list', () => {
      const { expectedQuads, items, grapoi, predicates } = datasets.addList()
      grapoi.addList(predicates, items)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should add the given items in the defined graphs to the list', () => {
      const { expectedQuads, items, grapoi, predicates } = datasets.addListGraphs()
      grapoi.addList(predicates, items)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should throw an error if the ptr is an any ptr', () => {
      const { items, grapoi, predicates } = datasets.any()
      throws(() => {
        grapoi.addList(predicates, items)
      })
    })
  })
  describe('.addOut', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.addOut, 'function')
    })
    it('should return itself', () => {
      const { objects, grapoi, predicates } = datasets.addOut()
      const result = grapoi.addOut(predicates, objects)
      strictEqual(result, grapoi)
    })
    it('should add quads for the given predicates and objects', () => {
      const { expectedQuads, objects, grapoi, predicates } = datasets.addOut()
      grapoi.addOut(predicates, objects)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should add quads for the given predicates and blank node if no object is given', () => {
      const { expectedQuads, grapoi, predicates } = datasets.addOutNoObject()
      grapoi.addOut(predicates)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should add quads for the given predicates, objects, and graphs', () => {
      const { expectedQuads, objects, grapoi, predicates } = datasets.addOutGraphs()
      grapoi.addOut(predicates, objects)
      datasetEqual(grapoi.dataset, expectedQuads)
    })
    it('should call the callback function with a path object for the new path', () => {
      const result = []
      const { expectedGrapois, objects, grapoi, predicates } = datasets.addOutPath()
      grapoi.addOut(predicates, objects, item => result.push(item))
      grapoiEqual(result, expectedGrapois)
    })
    it('should call the callback function as second argument with a grapoi object for the new path', () => {
      const result = []
      const { expectedGrapois, grapoi, predicates } = datasets.addOutNoObject()
      grapoi.addOut(predicates, item => result.push(item))
      grapoiEqual(result, expectedGrapois)
    })
  })
  describe('.base', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.base, 'function')
    })
    it('should throw an error if no base is given', () => {
      const { grapoi } = datasets.default()
      throws(() => {
        grapoi.base()
      }, {
        message: 'base parameter is required'
      })
    })
    it('should return a new Grapoi object', () => {
      const { expectedTerm, grapoi } = datasets.base()
      const result = grapoi.base(expectedTerm)
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
    it('should base the dateset', () => {
      const { expectedGrapoi, expectedTerm, grapoi } = datasets.base()
      const result = grapoi.base(expectedTerm)
      grapoiEqual(result, expectedGrapoi)
      datasetEqual(result.dataset, expectedGrapoi.dataset)
    })
    it('should support base argument given as ptr', () => {
      const { expectedGrapoi, grapoi } = datasets.base()
      const result = grapoi.base(expectedGrapoi)
      grapoiEqual(result, expectedGrapoi)
      datasetEqual(result.dataset, expectedGrapoi.dataset)
    })
  })
  describe('.best', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.best, 'function')
    })
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.best()
      const result = grapoi.best(obj => {
        return obj.ptrs.map(ptr => {
          return {
            dataset: ptr.dataset,
            score: parseInt(ptr.term.value.match(/(\d+)/)[1]),
            term: ptr.term
          }
        })
      })
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
    it('should contain a single Path for the ptr with the highest score', () => {
      const { expectedGrapoi, grapoi } = datasets.best()
      const result = grapoi.best(obj => {
        return obj.ptrs.map(ptr => {
          return {
            dataset: ptr.dataset,
            score: parseInt(ptr.term.value.match(/(\d+)/)[1]),
            term: ptr.term
          }
        })
      })
      grapoiEqual(result, expectedGrapoi)
    })
  })
  describe('.deleteIn', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.deleteIn, 'function')
    })
    it('should return itself', () => {
      const { grapoi, predicates } = datasets.deleteIn()
      const result = grapoi.deleteIn(predicates)
      strictEqual(result, grapoi)
    })
    it('should delete the quads matching O->S for all given predicates', () => {
      const { dataset, expectedQuads, grapoi, predicates } = datasets.deleteIn()
      grapoi.deleteIn(predicates)
      datasetEqual(dataset, expectedQuads)
    })
    it('should delete the quads matching O->S for all given predicates and subjects', () => {
      const { dataset, expectedQuads, grapoi, predicates, subjects } = datasets.deleteInSubjects()
      grapoi.deleteIn(predicates, subjects)
      datasetEqual(dataset, expectedQuads)
    })
  })
  describe('.deleteList', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.deleteList, 'function')
    })
    it('should return itself', () => {
      const { grapoi } = datasets.deleteList()
      const result = grapoi.deleteList([null])
      strictEqual(result, grapoi)
    })
    it('should delete all quads related to the list', () => {
      const { dataset, expectedQuads, grapoi, predicates } = datasets.deleteList()
      grapoi.deleteList(predicates)
      datasetEqual(dataset, expectedQuads)
    })
  })
  describe('.deleteOut', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.deleteOut, 'function')
    })
    it('should return itself', () => {
      const { grapoi, predicates } = datasets.deleteOut()
      const result = grapoi.deleteOut(predicates)
      strictEqual(result, grapoi)
    })
    it('should delete the quads matching S->O for all given predicates', () => {
      const { dataset, expectedQuads, grapoi, predicates } = datasets.deleteOut()
      grapoi.deleteOut(predicates)
      datasetEqual(dataset, expectedQuads)
    })
    it('should delete the quads matching S->O for all given predicates and objects', () => {
      const { dataset, expectedQuads, objects, grapoi, predicates } = datasets.deleteOutObjects()
      grapoi.deleteOut(predicates, objects)
      datasetEqual(dataset, expectedQuads)
    })
  })
  describe('.execute', () => {
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.default()
      const result = grapoi.execute({})
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
  })
  describe('.executeAll', () => {
    it('should return a new Grapoi instance', () => {
      const { instructions, grapoi } = datasets.executeAll()
      const result = grapoi.executeAll(instructions)
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
  })
  describe('.filter', () => {
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.default()
      const result = grapoi.filter(() => true)
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
  })
  describe('.hasIn', () => {
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.default()
      const result = grapoi.hasIn()
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
  })
  describe('.hasOut', () => {
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.default()
      const result = grapoi.hasOut()
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
  })
  describe('.in', () => {
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.default()
      const result = grapoi.in()
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
  })
  describe('.list', () => {
    it('should return an iterator that loops over all items of the list', () => {
      const { items, grapoi } = datasets.list()
      const result = grapoi.list()
      strictEqual(typeof result[Symbol.iterator], 'function')
      const resultItems = [...result]
      strictEqual(resultItems.length, items.length)
      for (let index = 0; index < items.length; index++) {
        strictEqual(resultItems[index] instanceof Grapoi, true)
        strictEqual(resultItems[index].term.equals(items[index]), true)
      }
    })
  })
  describe('.node', () => {
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.default()
      const result = grapoi.node()
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
  })
  describe('.rebase', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.rebase, 'function')
    })
    it('should throw an error if no base is given', () => {
      const { grapoi } = datasets.default()
      throws(() => {
        grapoi.rebase()
      }, {
        message: 'base parameter is required'
      })
    })
    it('should return a new Grapoi object', () => {
      const { expectedTerm, grapoi } = datasets.rebase()
      const result = grapoi.rebase(expectedTerm)
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
    it('should rebase the dateset', () => {
      const { expectedGrapoi, expectedTerm, grapoi } = datasets.rebase()
      const result = grapoi.rebase(expectedTerm)
      grapoiEqual(result, expectedGrapoi)
      datasetEqual(result.dataset, expectedGrapoi.dataset)
    })
    it('should support base argument given as ptr', () => {
      const { expectedGrapoi, grapoi } = datasets.rebase()
      const result = grapoi.rebase(expectedGrapoi)
      grapoiEqual(result, expectedGrapoi)
      datasetEqual(result.dataset, expectedGrapoi.dataset)
    })
    it('should rebase datasets with empty named nodes', () => {
      const { expectedGrapoi, expectedTerm, grapoi } = datasets.rebaseEmpty()
      const result = grapoi.rebase(expectedTerm)
      grapoiEqual(result, expectedGrapoi)
      datasetEqual(result.dataset, expectedGrapoi.dataset)
    })
    it('should rebase datasets with relative named nodes', () => {
      const { expectedGrapoi, expectedTerm, grapoi } = datasets.rebaseRelative()
      const result = grapoi.rebase(expectedTerm)
      grapoiEqual(result, expectedGrapoi)
      datasetEqual(result.dataset, expectedGrapoi.dataset)
    })
  })
  describe('.replace', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.replace, 'function')
    })
    it('should throw an error if no base is given', () => {
      const { grapoi } = datasets.default()
      throws(() => {
        grapoi.replace()
      }, {
        message: 'replacement parameter is required'
      })
    })
    it('should return a new Grapoi object', () => {
      const { expectedTerm, grapoi } = datasets.replace()
      const result = grapoi.replace(expectedTerm)
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
    it('should replace the given term in the dateset', () => {
      const { expectedGrapoi, expectedTerm, grapoi } = datasets.replace()
      const result = grapoi.replace(expectedTerm)
      grapoiEqual(result, expectedGrapoi)
      datasetEqual(result.dataset, expectedGrapoi.dataset)
    })
    it('should support replacement argument given as ptr', () => {
      const { expectedGrapoi, grapoi } = datasets.replace()
      const result = grapoi.replace(expectedGrapoi)
      grapoiEqual(result, expectedGrapoi)
      datasetEqual(result.dataset, expectedGrapoi.dataset)
    })
  })
  describe('.out', () => {
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.default()
      const result = grapoi.out()
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
  })
  describe('.score', () => {
    it('should be a method', () => {
      const { grapoi } = datasets.default()
      strictEqual(typeof grapoi.score, 'function')
    })
    it('should return a new Grapoi instance', () => {
      const { grapoi } = datasets.score()
      const result = grapoi.score(obj => {
        return obj.ptrs.map(ptr => {
          return {
            dataset: ptr.dataset,
            score: parseInt(ptr.term.value.match(/(\d+)/)[1]),
            term: ptr.term
          }
        })
      })
      strictEqual(result instanceof Grapoi, true)
      notStrictEqual(result, grapoi)
    })
    it('should contain a Paths sorted by score', () => {
      const { expectedGrapoi, grapoi } = datasets.score()
      const result = grapoi.score(obj => {
        return obj.ptrs.map(ptr => {
          return {
            dataset: ptr.dataset,
            score: parseInt(ptr.term.value.match(/(\d+)/)[1]),
            term: ptr.term
          }
        })
      })
      grapoiEqual(result, expectedGrapoi)
    })
  })
  describe('[Symbol.iterator]', () => {
    it('should return an iterator that loops over all ptrs wrapped into a Grapoi object', () => {
      const { expectedGrapois, grapoi } = datasets.iterator()
      const result = [...grapoi]
      for (const item of result) {
        strictEqual(item instanceof Grapoi, true)
      }
      grapoiEqual(result, expectedGrapois)
    })
  })
})

================
File: test/Path.test.js
================
import { deepStrictEqual, notStrictEqual, strictEqual, throws } from 'assert'
import { describe, it } from 'mocha'
import { datasetEqual } from 'rdf-test/assert.js'
import Path from '../Path.js'
import datasets from './support/datasets.single.js'
import factory from './support/factory.js'
import * as ns from './support/namespaces.js'
import { grapoiEqual } from './support/toJSON.js'
describe('Path', () => {
  it('should be a constructor', () => {
    strictEqual(typeof Path, 'function')
  })
  it('should assign the given dataset to .dataset', () => {
    const { dataset } = datasets.default()
    const path = new Path({ dataset, term: null })
    strictEqual(path.dataset, dataset)
  })
  it('should throw an error if dataset is not given', () => {
    throws(() => {
      const ptr = new Path({})
      strictEqual(ptr, ptr)
    })
  })
  it('should use an empty array as default value for .edges', () => {
    const { dataset } = datasets.default()
    const path = new Path({ dataset, term: null })
    deepStrictEqual(path.edges, [])
  })
  it('should assign the given edges to .edges', () => {
    const { dataset, edges } = datasets.constructorEdges()
    const path = new Path({ dataset, edges })
    strictEqual(path.edges, edges)
  })
  it('should throw an error if edges and term are not given', () => {
    const { dataset } = datasets.default()
    throws(() => {
      const ptr = new Path({ dataset })
      strictEqual(ptr, ptr)
    })
  })
  it('should throw an error if edges and term are given', () => {
    const { dataset, edges, term } = datasets.constructorEdgesTerm()
    throws(() => {
      const ptr = new Path({ dataset, edges, term })
      strictEqual(ptr, ptr)
    })
  })
  it('should assign the given factory to .factory', () => {
    const { dataset, term } = datasets.default()
    const path = new Path({ dataset, factory, term })
    strictEqual(path.factory, factory)
  })
  it('should assign the given term to ._term', () => {
    const { dataset, term } = datasets.default()
    const path = new Path({ dataset, term })
    strictEqual(path._term, term)
  })
  it('should assign the given graph to ._graph', () => {
    const { dataset, graph, term } = datasets.defaultGraph()
    const path = new Path({ dataset, graph, term })
    strictEqual(path._graph, graph)
  })
  describe('.graph', () => {
    it('should be a term property', () => {
      const { ptr } = datasets.defaultGraph()
      strictEqual(typeof ptr.graph, 'object')
      strictEqual(typeof ptr.graph.termType, 'string')
    })
    it('should be the graph given in the constructor', () => {
      const { graph, ptr } = datasets.defaultGraph()
      strictEqual(ptr.graph.equals(graph), true)
    })
    it('should be the graph of the last edge if no graph was given in the constructor', () => {
      const { edges, ptr } = datasets.graphEdges()
      strictEqual(ptr.graph.equals(edges[edges.length - 1].graph), true)
    })
    it('should be null if null was given in the constructor, even if there are edges', () => {
      const { ptr } = datasets.graphEdgesNull()
      strictEqual(ptr.graph, null)
    })
    it('should be undefined if no graph is given', () => {
      const { ptr } = datasets.default()
      strictEqual(ptr.graph, undefined)
    })
  })
  describe('.length', () => {
    it('should be a number property', () => {
      const { ptr } = datasets.length()
      strictEqual(typeof ptr.length, 'number')
    })
    it('should return the number of nodes', () => {
      const { ptr } = datasets.length()
      strictEqual(ptr.length, 3)
    })
    it('should return one if the path has no edges', () => {
      const { ptr } = datasets.default()
      strictEqual(ptr.length, 1)
    })
  })
  describe('.startTerm', () => {
    it('should be the term argument if there are no edges', () => {
      const { dataset } = datasets.default()
      const term = ns.ex.subject
      const path = new Path({ dataset, term })
      strictEqual(path.startTerm, term)
    })
    it('should be .startTerm of the first edge', () => {
      const { dataset, expectedPtrs } = datasets.startTerm()
      const edges = [expectedPtrs[0].edges[0], expectedPtrs[1].edges[0]]
      const path = new Path({ dataset, edges })
      strictEqual(path.startTerm.equals(ns.ex.start), true)
    })
  })
  describe('.value', () => {
    it('should return undefined if it is an any ptr', () => {
      const { ptr } = datasets.any()
      strictEqual(ptr.value, undefined)
    })
    it('should return the value of the term', () => {
      const { ptr } = datasets.value()
      strictEqual(ptr.value, ns.ex.start.value)
    })
  })
  describe('.addIn', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.addIn, 'function')
    })
    it('should return itself', () => {
      const { predicates, ptr, subjects } = datasets.addIn()
      const result = ptr.addIn(predicates, subjects)
      strictEqual(result, ptr)
    })
    it('should add quads for the given predicates and subjects', () => {
      const { predicates, ptr, quads, subjects } = datasets.addIn()
      ptr.addIn(predicates, subjects)
      datasetEqual(ptr.dataset, quads)
    })
    it('should add quads for the given predicates, subjects, and graph', () => {
      const { predicates, ptr, quads, subjects } = datasets.addInGraph()
      ptr.addIn(predicates, subjects)
      datasetEqual(ptr.dataset, quads)
    })
    it('should call the callback function with a path object for the new path', () => {
      const { predicates, ptr, expectedPtrs, subjects } = datasets.addIn()
      const result = []
      ptr.addIn(predicates, subjects, path => result.push(path))
      grapoiEqual(result, expectedPtrs)
    })
  })
  describe('.addList', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.addList, 'function')
    })
    it('should return itself', () => {
      const { items, predicates, ptr } = datasets.addList()
      const result = ptr.addList(predicates, items)
      strictEqual(result, ptr)
    })
    it('should create an empty list if an empty item list is given', () => {
      const { dataset, items, predicates, ptr } = datasets.addListEmpty()
      ptr.addList(predicates, items)
      datasetEqual(ptr.dataset, dataset)
    })
    it('should add the given items to the list', () => {
      const { dataset, items, predicates, ptr } = datasets.addList()
      ptr.addList(predicates, items)
      datasetEqual(ptr.dataset, dataset)
    })
    it('should add the given items to the list for the given graph', () => {
      const { dataset, items, predicates, ptr } = datasets.addListGraph()
      ptr.addList(predicates, items)
      datasetEqual(ptr.dataset, dataset)
    })
    it('should throw an error if the ptr is an any ptr', () => {
      const { items, predicates, ptr } = datasets.addListAny()
      throws(() => {
        ptr.addList(predicates, items)
      })
    })
  })
  describe('.addOut', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.addOut, 'function')
    })
    it('should return itself', () => {
      const { objects, predicates, ptr } = datasets.addOut()
      const result = ptr.addOut(predicates, objects)
      strictEqual(result, ptr)
    })
    it('should add quads for the given predicates and objects', () => {
      const { objects, predicates, ptr, quads } = datasets.addOut()
      ptr.addOut(predicates, objects)
      datasetEqual(ptr.dataset, quads)
    })
    it('should add quads for the given predicates, objects and graph', () => {
      const { objects, predicates, ptr, quads } = datasets.addOutGraph()
      ptr.addOut(predicates, objects)
      datasetEqual(ptr.dataset, quads)
    })
    it('should call the callback function with a path object for the new path', () => {
      const { objects, predicates, ptr, expectedPtrs } = datasets.addOut()
      const result = []
      ptr.addOut(predicates, objects, path => result.push(path))
      grapoiEqual(result, expectedPtrs)
    })
  })
  describe('.deleteIn', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.deleteIn, 'function')
    })
    it('should return itself', () => {
      const { predicates, ptr, subjects } = datasets.deleteIn()
      const result = ptr.deleteIn(predicates, subjects)
      strictEqual(result, ptr)
    })
    it('should delete the quads matching the O->PS pattern', () => {
      const { expectedQuads, predicates, ptr, subjects } = datasets.deleteIn()
      ptr.deleteIn(predicates, subjects)
      datasetEqual(ptr.dataset, expectedQuads)
    })
  })
  describe('.deleteList', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.deleteList, 'function')
    })
    it('should return itself', () => {
      const { predicates, ptr } = datasets.deleteList()
      const result = ptr.deleteList(predicates)
      strictEqual(result, ptr)
    })
    it('should delete all quads related to the list', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteList()
      ptr.deleteList(predicates)
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should delete empty lists', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteListEmpty()
      ptr.deleteList(predicates)
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should handle lists with rdf:first count zero', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteListFirst0()
      ptr.deleteList(predicates)
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should handle lists with rdf:first count greater one', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteListFirst2()
      ptr.deleteList(predicates)
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should handle lists with rdf:rest count zero', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteListRest0()
      ptr.deleteList(predicates)
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should handle lists with rdf:rest count greater one', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteListRest2()
      ptr.deleteList(predicates)
      datasetEqual(ptr.dataset, expectedQuads)
    })
  })
  describe('.deleteOut', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.deleteOut, 'function')
    })
    it('should return itself', () => {
      const { objects, predicates, ptr } = datasets.deleteIn()
      const result = ptr.deleteOut(predicates, objects)
      strictEqual(result, ptr)
    })
    it('should delete the quads matching the S->PO pattern', () => {
      const { expectedQuads, objects, predicates, ptr } = datasets.deleteOut()
      ptr.deleteOut(predicates, objects)
      datasetEqual(ptr.dataset, expectedQuads)
    })
  })
  describe('.execute', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.execute, 'function')
    })
    it('should use the ptr as argument', () => {
      const { objects, predicates, ptr, expectedPtrs } = datasets.default()
      const result = ptr.execute({
        predicates,
        objects,
        callback: (edge, ptr) => ptr.extend(edge)
      })
      grapoiEqual(result, expectedPtrs)
    })
    it('should forward the given operation argument', () => {
      const { dataset, graph, items, predicates, ptr } = datasets.executeAddList()
      ptr.execute({
        operation: 'addList',
        predicates,
        items,
        graphs: [graph]
      })
      datasetEqual(ptr.dataset, dataset)
    })
    it('should forward the given quantifier argument', () => {
      const { expectedQuads, predicates, ptr } = datasets.executeQuantifier()
      const result = ptr.execute({
        quantifier: 'oneOrMore',
        predicates,
        callback: (edge, ptr) => ptr.extend(edge)
      })
      grapoiEqual(result, expectedQuads)
    })
    it('should forward the given start and end argument', () => {
      const { predicates, ptr, expectedPtrs, subjects } = datasets.executeStartEnd()
      const result = ptr.execute({
        start: 'object',
        end: 'subject',
        subjects,
        predicates,
        callback: (edge, ptr) => ptr.extend(edge)
      })
      grapoiEqual(result, expectedPtrs)
    })
    it('should forward the given subjects argument', () => {
      const { predicates, ptr, expectedPtrs, subjects } = datasets.executeSubject()
      const result = ptr.execute({
        start: 'object',
        end: 'subject',
        subjects,
        predicates,
        callback: (edge, ptr) => ptr.extend(edge)
      })
      grapoiEqual(result, expectedPtrs)
    })
    it('should forward the given predicates argument', () => {
      const { objects, predicates, ptr, expectedPtrs } = datasets.executePredicates()
      const result = ptr.execute({
        predicates,
        objects
      })
      grapoiEqual(result, expectedPtrs)
    })
    it('should forward the given objects argument', () => {
      const { objects, predicates, ptr, expectedPtrs } = datasets.executeObjects()
      const result = ptr.execute({
        predicates,
        objects
      })
      grapoiEqual(result, expectedPtrs)
    })
    it('should forward the given items argument', () => {
      const { dataset, graph, items, predicates, ptr } = datasets.executeAddList()
      ptr.execute({
        operation: 'addList',
        predicates,
        items,
        graphs: [graph]
      })
      datasetEqual(ptr.dataset, dataset)
    })
    it('should forward the given callback argument', () => {
      const { edges, graph, objects, predicates, ptr } = datasets.executeAddOut()
      const result = []
      ptr.execute({
        operation: 'add',
        start: 'subject',
        end: 'object',
        predicates,
        objects,
        graphs: [graph],
        callback: edge => result.push(edge)
      })
      grapoiEqual(result, edges)
    })
  })
  describe('.extend', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.extend, 'function')
    })
    it('should return a new path object', () => {
      const { ptr, quads } = datasets.extend()
      const result = ptr.extend({
        quad: quads[0],
        start: 'subject',
        end: 'object'
      })
      strictEqual(result instanceof Path, true)
      notStrictEqual(result, ptr)
    })
    it('should copy the dataset', () => {
      const { ptr, quads } = datasets.extend()
      const result = ptr.extend({
        quad: quads[0],
        start: 'subject',
        end: 'object'
      })
      strictEqual(result.dataset, ptr.dataset)
    })
    it('should copy the factory', () => {
      const { ptr, quads } = datasets.extend()
      const result = ptr.extend({
        quad: quads[0],
        start: 'subject',
        end: 'object'
      })
      strictEqual(result.factory, ptr.factory)
    })
    it('should copy the graph', () => {
      const { graph, ptr, quads } = datasets.extendGraph()
      const result = ptr.extend({
        quad: quads[0],
        start: 'subject',
        end: 'object'
      })
      strictEqual(result._graph, graph)
    })
    it('should copy a null graph', () => {
      const { graph, ptr, quads } = datasets.extendGraphNull()
      const result = ptr.extend({
        quad: quads[0],
        start: 'subject',
        end: 'object'
      })
      strictEqual(result._graph, graph)
    })
    it('should copy a undefined graph', () => {
      const { graph, ptr, quads } = datasets.extend()
      const result = ptr.extend({
        quad: quads[0],
        start: 'subject',
        end: 'object'
      })
      strictEqual(result._graph, graph)
    })
    it('should return a path object with the given edge appended', () => {
      const { edges, expectedQuads, ptr } = datasets.extend()
      const result = ptr.extend(edges[1])
      grapoiEqual(result, expectedQuads)
    })
  })
  describe('.hasIn', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.hasIn, 'function')
    })
    it('should return all expectedPtrs matching O->S for all given properties', () => {
      const { predicates, expectedPtrs, ptr } = datasets.hasIn()
      const result = ptr.hasIn(predicates)
      grapoiEqual(result, expectedPtrs)
    })
    it('should return all expectedPtrs matching O->S for all given properties in the defined graph', () => {
      const { predicates, expectedPtrs, ptr } = datasets.hasInGraph()
      const result = ptr.hasIn(predicates)
      grapoiEqual(result, expectedPtrs)
    })
    it('should return all expectedPtrs matching O->S for all given properties and subjects', () => {
      const { predicates, expectedPtrs, ptr, subjects } = datasets.hasInSubjects()
      const result = ptr.hasIn(predicates, subjects)
      grapoiEqual(result, expectedPtrs)
    })
  })
  describe('.hasOut', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.hasOut, 'function')
    })
    it('should return all expectedPtrs matching S->O for all given properties', () => {
      const { predicates, expectedPtrs, ptr } = datasets.hasOut()
      const result = ptr.hasOut(predicates)
      grapoiEqual(result, expectedPtrs)
    })
    it('should return all expectedPtrs matching S->O for all given properties in the defined graph', () => {
      const { predicates, expectedPtrs, ptr } = datasets.hasOutGraph()
      const result = ptr.hasOut(predicates)
      grapoiEqual(result, expectedPtrs)
    })
    it('should return all expectedPtrs matching S->O for all given properties and subjects', () => {
      const { objects, predicates, expectedPtrs, ptr } = datasets.hasOutObjects()
      const result = ptr.hasOut(predicates, objects)
      grapoiEqual(result, expectedPtrs)
    })
  })
  describe('.in', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.in, 'function')
    })
    it('should return all expectedPtrs traversing O->S for all given properties', () => {
      const { predicates, expectedPtrs, ptr } = datasets.in()
      const result = ptr.in(predicates)
      grapoiEqual(result, expectedPtrs)
    })
    it('should return all expectedPtrs traversing O->S for all given properties in the defined graph', () => {
      const { predicates, expectedPtrs, ptr } = datasets.inGraph()
      const result = ptr.in(predicates)
      grapoiEqual(result, expectedPtrs)
    })
    it('should return all expectedPtrs traversing O->S for all given properties and subjects', () => {
      const { predicates, expectedPtrs, ptr, subjects } = datasets.inSubjects()
      const result = ptr.in(predicates, subjects)
      grapoiEqual(result, expectedPtrs)
    })
  })
  describe('.isAny', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.isAny, 'function')
    })
    it('should return true if the term is null', () => {
      const { ptr } = datasets.any()
      strictEqual(ptr.isAny(), true)
    })
    it('should return false if the term is not null', () => {
      const { ptr } = datasets.default()
      strictEqual(ptr.isAny(), false)
    })
  })
  describe('.isList', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.isList, 'function')
    })
    it('should return false if the ptr is an any ptr', () => {
      const { ptr } = datasets.any()
      strictEqual(ptr.isList(), false)
    })
    it('should return true if the ptr is a list', () => {
      const { ptr } = datasets.isList()
      strictEqual(ptr.isList(), true)
    })
    it('should return true if the ptr is an empty list', () => {
      const { ptr } = datasets.isListEmpty()
      strictEqual(ptr.isList(), true)
    })
  })
  describe('.list', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.list, 'function')
    })
    it('should return an iterator that loops over all items of the list', () => {
      const { ptr } = datasets.list()
      const result = ptr.list()
      strictEqual(typeof result[Symbol.iterator], 'function')
      const items = [...result]
      strictEqual(items.length, 2)
      strictEqual(items[0] instanceof Path, true)
      strictEqual(items[0].term.equals(ns.ex.end1), true)
      strictEqual(items[1] instanceof Path, true)
      strictEqual(items[1].term.equals(ns.ex.end2), true)
    })
    it('should return undefined if the node is not a list', () => {
      const { ptr } = datasets.default()
      strictEqual(ptr.list(), undefined)
    })
    it('should throw an error if rdf:first count is zero', () => {
      const { ptr } = datasets.listFirst0()
      throws(() => {
        Array.from(ptr.list())
      })
    })
    it('should throw an error if rdf:first count is greater one', () => {
      const { ptr } = datasets.listFirst2()
      throws(() => {
        Array.from(ptr.list())
      })
    })
    it('should throw an error if rdf:rest count is zero', () => {
      const { ptr } = datasets.listRest0()
      throws(() => {
        Array.from(ptr.list())
      })
    })
    it('should throw an error if rdf:rest count is greater one', () => {
      const { ptr } = datasets.listRest2()
      throws(() => {
        Array.from(ptr.list())
      })
    })
  })
  describe('.nodes', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.nodes, 'function')
    })
    it('should return an iterator', () => {
      const { ptr } = datasets.default()
      const result = ptr.nodes()
      strictEqual(typeof result[Symbol.iterator], 'function')
    })
    it('should loop over all nodes', () => {
      const { ptr } = datasets.nodes()
      const result = [...ptr.nodes()]
      strictEqual(result.length, ptr.length)
      for (let index = 0; index < ptr.edges.length; index++) {
        strictEqual(result[index].dataset, ptr.edges[index].dataset)
        strictEqual(result[index].term.equals(ptr.edges[index].startTerm), true)
      }
      strictEqual(result[ptr.edges.length].dataset, ptr.edges[ptr.edges.length - 1].dataset)
      strictEqual(result[ptr.edges.length].term.equals(ptr.edges[ptr.edges.length - 1].term), true)
    })
    it('should loop over the term of the ptr if there are no edges', () => {
      const { dataset, ptr } = datasets.default()
      const result = [...ptr.nodes()]
      strictEqual(result.length, 1)
      strictEqual(result[0].dataset, dataset)
      strictEqual(result[0].term.equals(ptr.term), true)
    })
  })
  describe('.out', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.out, 'function')
    })
    it('should return all expectedPtrs traversing S->O for all given properties', () => {
      const { predicates, ptr, expectedPtrs } = datasets.out()
      const result = ptr.out(predicates)
      grapoiEqual(result, expectedPtrs)
    })
    it('should return all expectedPtrs traversing S->O for all given properties in the defined graph', () => {
      const { predicates, ptr, expectedPtrs } = datasets.outGraph()
      const result = ptr.out(predicates)
      grapoiEqual(result, expectedPtrs)
    })
    it('should return all expectedPtrs traversing S->O for all given properties and subjects', () => {
      const { objects, predicates, expectedPtrs, ptr } = datasets.outObjects()
      const result = ptr.out(predicates, objects)
      grapoiEqual(result, expectedPtrs)
    })
  })
  describe('.quads', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.quads, 'function')
    })
    it('should return an iterator', () => {
      const { ptr } = datasets.default()
      const result = ptr.quads()
      strictEqual(typeof result[Symbol.iterator], 'function')
    })
    it('should loop over all quads', () => {
      const { dataset, ptr } = datasets.quadsEdges()
      const quads = ptr.quads()
      datasetEqual(quads, dataset)
    })
    it('should return an empty iterator if there are no edges', () => {
      const { ptr } = datasets.default()
      const result = [...ptr.quads()]
      strictEqual(result.length, 0)
    })
  })
  describe('.trim', () => {
    it('should be a method', () => {
      const { ptr } = datasets.default()
      strictEqual(typeof ptr.trim, 'function')
    })
    it('should trim the edges from the path and keep only the term', () => {
      const { expectedPtr, ptr } = datasets.trim()
      const result = ptr.trim()
      grapoiEqual(result, expectedPtr)
    })
  })
})

================
File: test/PathList.test.js
================
import { notStrictEqual, strictEqual, throws } from 'assert'
import { describe, it } from 'mocha'
import { datasetEqual } from 'rdf-test/assert.js'
import Path from '../Path.js'
import PathList from '../PathList.js'
import datasets from './support/datasets.multi.js'
import factory from './support/factory.js'
import * as ns from './support/namespaces.js'
import { grapoiEqual } from './support/toJSON.js'
describe('PathList', () => {
  it('should be a constructor', () => {
    strictEqual(typeof PathList, 'function')
  })
  it('should assign the given factory', () => {
    const { dataset } = datasets.default()
    const ptrList = new PathList({ dataset, factory })
    strictEqual(ptrList.factory, factory)
  })
  it('should use an any Path ptr if no ptrs are given', () => {
    const { dataset } = datasets.default()
    const ptrList = new PathList({ dataset })
    strictEqual(ptrList.ptrs.length, 1)
    strictEqual(ptrList.ptrs[0] instanceof Path, true)
    strictEqual(ptrList.ptrs[0].term, null)
  })
  it('should use the given ptrs', () => {
    const { ptrs } = datasets.constructorPtrs()
    const ptrList = new PathList({ ptrs })
    strictEqual(ptrList.ptrs.length, ptrs.length)
    for (let index = 0; index < ptrs.length; index++) {
      strictEqual(ptrList.ptrs[index], ptrs[index])
    }
  })
  it('should create a Path ptr for each of the given terms', () => {
    const { dataset, terms } = datasets.default()
    const ptrList = new PathList({ dataset, terms })
    strictEqual(ptrList.ptrs.length, terms.length)
    for (let index = 0; index < terms.length; index++) {
      strictEqual(ptrList.ptrs[index] instanceof Path, true)
      strictEqual(ptrList.ptrs[index].term.equals(terms[index]), true)
    }
  })
  it('should create a Path ptr for each of the given terms and graphs', () => {
    const { dataset, graphs, terms } = datasets.constructorGraphs()
    const ptrList = new PathList({ dataset, graphs, terms })
    strictEqual(ptrList.ptrs.length, terms.length * graphs.length)
    for (let index = 0; index < terms.length * graphs.length; index++) {
      strictEqual(ptrList.ptrs[index].term.equals(terms[Math.floor(index / 2)]), true)
      strictEqual(ptrList.ptrs[index].graph.equals(graphs[index % 2]), true)
    }
  })
  it('should create a Path ptr for each of the given terms with the given factory', () => {
    const { dataset, terms } = datasets.default()
    const ptrList = new PathList({ dataset, factory, terms })
    strictEqual(ptrList.ptrs.length, terms.length)
    for (let index = 0; index < terms.length; index++) {
      strictEqual(ptrList.ptrs[index].factory, factory)
    }
  })
  it('should prioritize ptrs over terms', () => {
    const { dataset, ptrList, terms } = datasets.constructorPtrsVsTerms()
    const result = new PathList({ dataset, factory, ptrs: ptrList.ptrs, terms })
    grapoiEqual(result, ptrList)
  })
  describe('.dataset', () => {
    it('should be the dataset of the ptr', () => {
      const dataset = factory.dataset()
      const ptrList = new PathList({ factory, ptrs: [{ dataset }] })
      const result = ptrList.dataset
      strictEqual(result, dataset)
    })
    it('should be null if there are multiple datasets', () => {
      const ptrs = [{ dataset: factory.dataset() }, { dataset: factory.dataset() }]
      const ptrList = new PathList({ factory, ptrs })
      strictEqual(ptrList.dataset, null)
    })
    it('should be the dataset of the ptrs if all datasets are equal', () => {
      const dataset = factory.dataset()
      const ptrList = new PathList({ factory, ptrs: [{ dataset }, { dataset }] })
      strictEqual(ptrList.dataset, dataset)
    })
  })
  describe('.datasets', () => {
    it('should be an array property', () => {
      const ptrList = new PathList({ dataset: factory.dataset(), factory })
      strictEqual(Array.isArray(ptrList.datasets), true)
    })
    it('should contain all datasets of the ptrs', () => {
      const ptrs = [{ dataset: factory.dataset() }, { dataset: factory.dataset() }]
      const ptrList = new PathList({ factory, ptrs })
      const result = ptrList.datasets
      strictEqual(result.length, ptrs.length)
      for (let index = 0; index < ptrs.length; index++) {
        strictEqual(result[index], ptrs[index].dataset)
      }
    })
    it('should keep duplicates', () => {
      const dataset = factory.dataset()
      const ptrList = new PathList({ factory, ptrs: [{ dataset }, { dataset }] })
      const result = ptrList.datasets
      strictEqual(result.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result[index], dataset)
      }
    })
  })
  describe('.term', () => {
    it('should be the term of the ptr', () => {
      const term = ns.ex.start1
      const ptrList = new PathList({ factory, ptrs: [{ term }] })
      strictEqual(ptrList.term.equals(term), true)
    })
    it('should be null if the ptr term is null', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: null }] })
      strictEqual(ptrList.term, null)
    })
    it('should be null if the term of all ptrs is null', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: null }, { term: null }] })
      strictEqual(ptrList.term, null)
    })
    it('should be undefined if there are multiple terms', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: ns.ex.start1 }, { term: ns.ex.start2 }] })
      strictEqual(ptrList.term, undefined)
    })
    it('should be undefined if there is a ptr with the term null and a ptr with a term not null', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: ns.ex.start1 }, { term: null }] })
      strictEqual(ptrList.dataset, undefined)
    })
    it('should be the term of the ptrs if all terms are equal', () => {
      const term = ns.ex.start1
      const ptrList = new PathList({ factory, ptrs: [{ term }, { term }] })
      strictEqual(ptrList.term.equals(term), true)
    })
  })
  describe('.terms', () => {
    it('should be an array property', () => {
      const ptrList = new PathList({ dataset: factory.dataset(), factory })
      strictEqual(Array.isArray(ptrList.terms), true)
    })
    it('should contain all terms of the ptrs', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: ns.ex.start1 }, { term: ns.ex.start2 }] })
      const result = ptrList.terms
      strictEqual(result.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result[index].equals(ptrList.ptrs[index].term), true)
      }
    })
    it('should keep term duplicates', () => {
      const term = ns.ex.start1
      const ptrList = new PathList({ factory, ptrs: [{ term }, { term }] })
      const result = ptrList.terms
      strictEqual(result.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result[index].equals(term), true)
      }
    })
    it('should keep null terms', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: null }, { term: null }] })
      const result = ptrList.terms
      strictEqual(result.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result[index], null)
      }
    })
  })
  describe('.value', () => {
    it('should be the term value of the ptr', () => {
      const term = ns.ex.start1
      const ptrList = new PathList({ factory, ptrs: [{ term }] })
      strictEqual(ptrList.value, term.value)
    })
    it('should be undefined if the ptr term is null', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: null }] })
      strictEqual(ptrList.value, undefined)
    })
    it('should be undefined if the term of all ptrs is null', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: null }, { term: null }] })
      strictEqual(ptrList.value, undefined)
    })
    it('should be undefined if there are multiple terms', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: ns.ex.start1 }, { term: ns.ex.start2 }] })
      strictEqual(ptrList.value, undefined)
    })
    it('should be undefined if there is a ptr with the term null and a ptr with a term not null', () => {
      const ptrList = new PathList({ factory, ptrs: [{ term: ns.ex.start1 }, { term: null }] })
      strictEqual(ptrList.dataset, undefined)
    })
    it('should be the term value of the ptrs if all terms are equal', () => {
      const term = ns.ex.start1
      const ptrList = new PathList({ factory, ptrs: [{ term }, { term }] })
      strictEqual(ptrList.value, term.value)
    })
  })
  describe('.values', () => {
    it('should be an array property', () => {
      const ptrList = new PathList({ dataset: factory.dataset(), factory })
      strictEqual(Array.isArray(ptrList.values), true)
    })
    it('should contain all term values of the ptrs', () => {
      const ptrs = [{ value: ns.ex.start1.value }, { value: ns.ex.start2.value }]
      const ptrList = new PathList({ factory, ptrs })
      const result = ptrList.values
      strictEqual(result.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result[index], ptrList.ptrs[index].value)
      }
    })
    it('should keep value duplicates', () => {
      const value = ns.ex.start1.value
      const ptrList = new PathList({ factory, ptrs: [{ value }, { value }] })
      const result = ptrList.values
      strictEqual(result.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result[index], value)
      }
    })
    it('should keep undefined values', () => {
      const ptrList = new PathList({ factory, ptrs: [{}, {}] })
      const result = ptrList.values
      strictEqual(result.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result[index], undefined)
      }
    })
  })
  describe('.addIn', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.addIn, 'function')
    })
    it('should return itself', () => {
      const { objects, ptrList, predicates } = datasets.addIn()
      const result = ptrList.addIn(predicates, objects)
      strictEqual(result, ptrList)
    })
    it('should add quads for the given predicates and subjects', () => {
      const { expectedQuads, ptrList, predicates, subjects } = datasets.addIn()
      ptrList.addIn(predicates, subjects)
      datasetEqual(ptrList.dataset, expectedQuads)
    })
    it('should add quads for the given predicates, subjects, and graphs', () => {
      const { expectedQuads, ptrList, predicates, subjects } = datasets.addInGraphs()
      ptrList.addIn(predicates, subjects)
      datasetEqual(ptrList.dataset, expectedQuads)
    })
    it('should call the callback function with a path object for the new path', () => {
      const result = []
      const { expectedPtrLists, ptrList, predicates, subjects } = datasets.addInPath()
      ptrList.addIn(predicates, subjects, ptrList => result.push(ptrList))
      grapoiEqual(result, expectedPtrLists)
    })
  })
  describe('.addList', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.addList, 'function')
    })
    it('should return itself', () => {
      const { ptrList, predicates, items } = datasets.addList()
      const result = ptrList.addList(predicates, items)
      strictEqual(result, ptrList)
    })
    it('should create an empty list if an empty item list is given', () => {
      const { expectedQuads, ptrList, predicates, items } = datasets.addListEmpty()
      ptrList.addList(predicates, items)
      datasetEqual(ptrList.dataset, expectedQuads)
    })
    it('should add the given items to the list', () => {
      const { expectedQuads, items, ptrList, predicates } = datasets.addList()
      ptrList.addList(predicates, items)
      datasetEqual(ptrList.dataset, expectedQuads)
    })
    it('should add the given items in the defined graphs to the list', () => {
      const { expectedQuads, items, ptrList, predicates } = datasets.addListGraphs()
      ptrList.addList(predicates, items)
      datasetEqual(ptrList.dataset, expectedQuads)
    })
    it('should throw an error if the ptr is an any ptr', () => {
      const { items, ptrList, predicates } = datasets.any()
      throws(() => {
        ptrList.addList(predicates, items)
      })
    })
  })
  describe('.addOut', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.addOut, 'function')
    })
    it('should return itself', () => {
      const { objects, ptrList, predicates } = datasets.addOut()
      const result = ptrList.addOut(predicates, objects)
      strictEqual(result, ptrList)
    })
    it('should add quads for the given predicates and objects', () => {
      const { expectedQuads, objects, ptrList, predicates } = datasets.addOut()
      ptrList.addOut(predicates, objects)
      datasetEqual(ptrList.dataset, expectedQuads)
    })
    it('should add quads for the given predicates, objects, and graphs', () => {
      const { expectedQuads, objects, ptrList, predicates } = datasets.addOutGraphs()
      ptrList.addOut(predicates, objects)
      datasetEqual(ptrList.dataset, expectedQuads)
    })
    it('should call the callback function with a path object for the new path', () => {
      const result = []
      const { expectedPtrLists, objects, ptrList, predicates } = datasets.addOutPath()
      ptrList.addOut(predicates, objects, ptrList => result.push(ptrList))
      grapoiEqual(result, expectedPtrLists)
    })
  })
  describe('.clone', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.clone, 'function')
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.clone()
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
    it('should copy the factory', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.clone()
      strictEqual(result.factory, ptrList.factory)
    })
    it('should copy the ptrs', () => {
      const { ptrList } = datasets.clone()
      const result = ptrList.clone()
      strictEqual(result.ptrs.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result.ptrs[index], ptrList.ptrs[index])
      }
    })
    it('should use the ptrs given as argument', () => {
      const { expectedPtrList, ptrList, ptrs } = datasets.clonePtrs()
      const result = ptrList.clone({ ptrs })
      grapoiEqual(result, expectedPtrList)
    })
  })
  describe('.deleteIn', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.deleteIn, 'function')
    })
    it('should return itself', () => {
      const { ptrList, predicates } = datasets.deleteIn()
      const result = ptrList.deleteIn(predicates)
      strictEqual(result, ptrList)
    })
    it('should delete the quads matching O->S for all given predicates', () => {
      const { dataset, expectedQuads, ptrList, predicates } = datasets.deleteIn()
      ptrList.deleteIn(predicates)
      datasetEqual(dataset, expectedQuads)
    })
    it('should delete the quads matching O->S for all given predicates and subjects', () => {
      const { dataset, expectedQuads, ptrList, predicates, subjects } = datasets.deleteInSubjects()
      ptrList.deleteIn(predicates, subjects)
      datasetEqual(dataset, expectedQuads)
    })
  })
  describe('.deleteList', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.deleteList, 'function')
    })
    it('should return itself', () => {
      const { ptrList } = datasets.deleteList()
      const result = ptrList.deleteList([null])
      strictEqual(result, ptrList)
    })
    it('should delete all quads related to the list', () => {
      const { dataset, expectedQuads, ptrList, predicates } = datasets.deleteList()
      ptrList.deleteList(predicates)
      datasetEqual(dataset, expectedQuads)
    })
  })
  describe('.deleteOut', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.deleteOut, 'function')
    })
    it('should return itself', () => {
      const { ptrList, predicates } = datasets.deleteOut()
      const result = ptrList.deleteOut(predicates)
      strictEqual(result, ptrList)
    })
    it('should delete the quads matching S->O for all given predicates', () => {
      const { dataset, expectedQuads, ptrList, predicates } = datasets.deleteOut()
      ptrList.deleteOut(predicates)
      datasetEqual(dataset, expectedQuads)
    })
    it('should delete the quads matching S->O for all given predicates and objects', () => {
      const { dataset, expectedQuads, objects, ptrList, predicates } = datasets.deleteOutObjects()
      ptrList.deleteOut(predicates, objects)
      datasetEqual(dataset, expectedQuads)
    })
  })
  describe('.execute', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.execute, 'function')
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.execute({})
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
    it('should combine the result of all ptrs', () => {
      const { expectedPtrList, ptrList, predicates } = datasets.execute()
      const result = ptrList.execute({
        quantifier: 'oneOrMore',
        predicates
      })
      grapoiEqual(result, expectedPtrList)
    })
  })
  describe('.executeAll', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.executeAll, 'function')
    })
    it('should execture all given instructions', () => {
      const { instructions, expectedPtrList, ptrList } = datasets.executeAll()
      const result = ptrList.executeAll(instructions)
      grapoiEqual(result, expectedPtrList)
    })
  })
  describe('.filter', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.filter, 'function')
    })
    it('should call the callback function with a PathList, index, and an array of all PathList objects for each ptr', () => {
      const args = []
      const { ptrList } = datasets.filter()
      ptrList.filter((ptrList, index, all) => args.push({ ptrList, index, all }))
      strictEqual(args.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(args[index].ptrList instanceof PathList, true)
        strictEqual(args[index].ptrList.term.equals(ptrList.ptrs[index].term), true)
        strictEqual(args[index].index, index)
        strictEqual(Array.isArray(args[index].all), true)
        strictEqual(args[index].all.length, ptrList.ptrs.length)
      }
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.filter(() => true)
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
    it('should return a PathList with all ptrs the callback returned true', () => {
      const { ptrList } = datasets.filter()
      const result = ptrList.filter(ptrList => ptrList.term.equals(ns.ex.start2))
      grapoiEqual(result.ptrs[0], ptrList.ptrs[1])
    })
  })
  describe('.hasIn', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.hasIn, 'function')
    })
    it('should return all nodes matching O->S for all given predicates', () => {
      const { expectedPtrList, ptrList, predicates } = datasets.hasIn()
      const result = ptrList.hasIn(predicates)
      grapoiEqual(result, expectedPtrList)
    })
    it('should return all nodes matching O->S for all given predicates and subjects', () => {
      const { expectedPtrList, ptrList, predicates, subjects } = datasets.hasInSubject()
      const result = ptrList.hasIn(predicates, subjects)
      grapoiEqual(result, expectedPtrList)
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.hasIn()
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
  })
  describe('.hasOut', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.hasOut, 'function')
    })
    it('should return all nodes matching S->O for all given predicates', () => {
      const { expectedPtrList, ptrList, predicates } = datasets.hasOut()
      const result = ptrList.hasOut(predicates)
      grapoiEqual(result, expectedPtrList)
    })
    it('should return all nodes matching S->O for all given predicates and subjects', () => {
      const { expectedPtrList, ptrList, predicates, objects } = datasets.hasOutObjects()
      const result = ptrList.hasOut(predicates, objects)
      grapoiEqual(result, expectedPtrList)
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.hasOut()
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
  })
  describe('.in', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.in, 'function')
    })
    it('should return all nodes traversing O->S for all given predicates', () => {
      const { expectedPtrList, ptrList, predicates } = datasets.in()
      const result = ptrList.in(predicates)
      grapoiEqual(result, expectedPtrList)
    })
    it('should return all nodes traversing O->S for all given predicates and subjects', () => {
      const { expectedPtrList, ptrList, predicates, subjects } = datasets.inSubjects()
      const result = ptrList.in(predicates, subjects)
      grapoiEqual(result, expectedPtrList)
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.in()
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
  })
  describe('.isAny', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.isAny, 'function')
    })
    it('should return false if ptrs is empty', () => {
      const { dataset } = datasets.any()
      const ptrList = new PathList({ dataset, factory, ptrs: [] })
      strictEqual(ptrList.isAny(), false)
    })
    it('should return true if any ptr call to isAny() returns true', () => {
      const ptrs = [{ isAny: () => false }, { isAny: () => true }]
      const ptrList = new PathList({ factory, ptrs })
      strictEqual(ptrList.isAny(), true)
    })
    it('should return false if all ptr calls to isAny() return false', () => {
      const ptrs = [{ isAny: () => false }, { isAny: () => false }]
      const ptrList = new PathList({ factory, ptrs })
      strictEqual(ptrList.isAny(), false)
    })
  })
  describe('.isList', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.isList, 'function')
    })
    it('should return false if ptrs is empty', () => {
      const { ptrList } = datasets.empty()
      strictEqual(ptrList.isList(), false)
    })
    it('should return false if ptrs length is not equal 1', () => {
      const { ptrList } = datasets.default()
      strictEqual(ptrList.isList(), false)
    })
    it('should return false if the ptr call to isList returns false', () => {
      const ptrs = [{ isList: () => false }]
      const ptrList = new PathList({ factory, ptrs })
      strictEqual(ptrList.isList(), false)
    })
    it('should return true if the ptr call to isList returns true', () => {
      const ptrs = [{ isList: () => true }]
      const ptrList = new PathList({ factory, ptrs })
      strictEqual(ptrList.isList(), true)
    })
  })
  describe('.list', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.list, 'function')
    })
    it('should return undefined is the ptr is not a list', () => {
      const { ptrList } = datasets.default()
      strictEqual(ptrList.list(), undefined)
    })
    it('should return an iterator that loops over all items of the list', () => {
      const { items, ptrList } = datasets.list()
      const result = ptrList.list()
      strictEqual(typeof result[Symbol.iterator], 'function')
      const resultItems = [...result]
      strictEqual(resultItems.length, items.length)
      for (let index = 0; index < items.length; index++) {
        strictEqual(resultItems[index] instanceof PathList, true)
        strictEqual(resultItems[index].term.equals(items[index]), true)
      }
    })
  })
  describe('.map', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.map, 'function')
    })
    it('should return an array', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.map(() => false)
      strictEqual(Array.isArray(result), true)
    })
    it('should call the callback function with a PathList, index, and an array of all PathList objects for each ptr', () => {
      const args = []
      const { ptrList } = datasets.map()
      ptrList.map((ptrList, index, all) => args.push({ ptrList, index, all }))
      strictEqual(args.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(args[index].ptrList instanceof PathList, true)
        strictEqual(args[index].ptrList.term.equals(ptrList.ptrs[index].term), true)
        strictEqual(args[index].index, index)
        strictEqual(Array.isArray(args[index].all), true)
        strictEqual(args[index].all.length, ptrList.ptrs.length)
      }
    })
    it('should return an array of return values of the callback function', () => {
      const { ptrList } = datasets.map()
      const result = ptrList.map(ptrList => ptrList.term)
      strictEqual(result.length, ptrList.ptrs.length)
      for (let index = 0; index < ptrList.ptrs.length; index++) {
        strictEqual(result[index].equals(ptrList.ptrs[index].term), true)
      }
    })
  })
  describe('.node', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.node, 'function')
    })
    it('should create a PathList object with the given terms wrapped in Path objects', () => {
      const { ptrList } = datasets.default()
      const terms = [factory.blankNode(), factory.literal('test'), ns.ex.start]
      const result = ptrList.node(terms)
      strictEqual(result instanceof PathList, true)
      strictEqual(result.ptrs.length, terms.length)
      for (let index = 0; index < terms.length; index++) {
        strictEqual(result.ptrs[index] instanceof Path, true)
        strictEqual(result.ptrs[index].term, terms[index])
      }
    })
    it('should create the Path objects with the factory of the PathList object', () => {
      const { ptrList } = datasets.default()
      const terms = [factory.blankNode(), factory.literal('test'), ns.ex.start]
      const result = ptrList.node(terms)
      for (let index = 0; index < terms.length; index++) {
        strictEqual(result.ptrs[index].factory, ptrList.factory)
      }
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.node([null])
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
  })
  describe('.out', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.out, 'function')
    })
    it('should return all nodes traversing S->O for all given predicates', () => {
      const { expectedPtrList, ptrList, predicates } = datasets.out()
      const result = ptrList.out(predicates)
      grapoiEqual(result, expectedPtrList)
    })
    it('should return all nodes traversing S->O for all given predicates and subjects', () => {
      const { expectedPtrList, objects, ptrList, predicates } = datasets.outObjects()
      const result = ptrList.out(predicates, objects)
      grapoiEqual(result, expectedPtrList)
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.out()
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
  })
  describe('.quads', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.quads, 'function')
    })
    it('should return an iterator', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.quads()
      strictEqual(typeof result[Symbol.iterator], 'function')
    })
    it('should loop over all quads', () => {
      const { expectedQuads, ptrList } = datasets.quads()
      datasetEqual(ptrList.quads(), expectedQuads)
    })
    it('should return an empty iterator if there are no edges', () => {
      const { ptrList } = datasets.default()
      const result = [...ptrList.quads()]
      strictEqual(result.length, 0)
    })
  })
  describe('.trim', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList.trim, 'function')
    })
    it('should trim the edges from all ptrs and keep only the term', () => {
      const { expectedPtrList, ptrList } = datasets.trim()
      const result = ptrList.trim()
      grapoiEqual(result, expectedPtrList)
    })
    it('should return a new PathList instance', () => {
      const { ptrList } = datasets.default()
      const result = ptrList.trim()
      strictEqual(result instanceof PathList, true)
      notStrictEqual(result, ptrList)
    })
  })
  describe('[Symbol.iterator]', () => {
    it('should be a method', () => {
      const { ptrList } = datasets.default()
      strictEqual(typeof ptrList[Symbol.iterator], 'function')
    })
    it('should return an iterator that loops over all ptrs wrapped into a PathList object', () => {
      const { expectedPtrLists, ptrList } = datasets.iterator()
      const result = [...ptrList]
      for (const item of result) {
        strictEqual(item instanceof PathList, true)
      }
      grapoiEqual(result, expectedPtrLists)
    })
  })
})

================
File: test/Processor.test.js
================
import { strictEqual, throws } from 'assert'
import { describe, it } from 'mocha'
import { datasetEqual } from 'rdf-test/assert.js'
import Edge from '../Edge.js'
import Processor from '../Processor.js'
import datasets from './support/datasets.single.js'
import * as ns from './support/namespaces.js'
import { grapoiEqual } from './support/toJSON.js'
describe('Processor', () => {
  describe('.add', () => {
    it('should be a static method', () => {
      strictEqual(typeof Processor.add, 'function')
    })
    it('should throw an error if a ptr without factory is given', () => {
      const { ptr } = datasets.addOutNoFactory()
      throws(() => {
        Processor.add({ ptr })
      })
    })
    it('should return the ptr', () => {
      const { graph, objects, predicates, ptr } = datasets.addOut()
      const result = Processor.add({
        ptr,
        start: 'subject',
        end: 'object',
        predicates,
        objects,
        graphs: [graph]
      })
      strictEqual(result, ptr)
    })
    it('should add quads for the given predicates and objects', () => {
      const { graph, objects, predicates, ptr, quads } = datasets.addOut()
      Processor.add({
        ptr,
        start: 'subject',
        end: 'object',
        predicates,
        objects,
        graphs: [graph]
      })
      datasetEqual(ptr.dataset, quads)
    })
    it('should call the callback function with an edge argument', () => {
      const { edges, graph, objects, predicates, ptr } = datasets.addOut()
      const result = []
      Processor.add({
        ptr,
        start: 'subject',
        end: 'object',
        predicates,
        objects,
        graphs: [graph],
        callback: edge => result.push(edge)
      })
      grapoiEqual(result, edges)
    })
  })
  describe('.addList', () => {
    it('should be a static method', () => {
      strictEqual(typeof Processor.addList, 'function')
    })
    it('should return the ptr', () => {
      const { graph, items, predicates, ptr } = datasets.addListEmpty()
      const result = Processor.addList({
        ptr,
        predicates,
        items,
        graphs: [graph]
      })
      strictEqual(result, ptr)
    })
    it('should add an empty list of items is empty', () => {
      const { graph, items, predicates, ptr, quads } = datasets.addListEmpty()
      Processor.addList({
        ptr,
        predicates,
        items,
        graphs: [graph]
      })
      datasetEqual(ptr.dataset, quads)
    })
    it('should add the given items to the list', () => {
      const { graph, items, predicates, ptr, quads } = datasets.addList()
      Processor.addList({
        ptr,
        predicates,
        items,
        graphs: [graph]
      })
      datasetEqual(ptr.dataset, quads)
    })
    it('should throw an error if the ptr is an any ptr', () => {
      const { graph, items, predicates, ptr } = datasets.addListAny()
      throws(() => {
        Processor.addList({
          ptr,
          predicates,
          items,
          graphs: [graph]
        })
      })
    })
  })
  describe('.delete', () => {
    it('should be a static method', () => {
      strictEqual(typeof Processor.delete, 'function')
    })
    it('should return the ptr', () => {
      const { ptr } = datasets.deleteOut()
      const result = Processor.delete({
        ptr,
        start: 'object',
        subjects: [null],
        predicates: [null],
        objects: [null]
      })
      strictEqual(result, ptr)
    })
    it('should loop over all subjects', () => {
      const { expectedQuads, ptr, subjects } = datasets.deleteObjectSubject()
      Processor.delete({
        ptr,
        start: 'object',
        subjects,
        predicates: [null],
        objects: [null]
      })
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should loop over all predicates', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteSubjectPredicate()
      Processor.delete({
        ptr,
        start: 'subject',
        subjects: [null],
        predicates,
        objects: [null]
      })
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should loop over all objects', () => {
      const { expectedQuads, objects, ptr } = datasets.deleteSubjectObject()
      Processor.delete({
        ptr,
        start: 'subject',
        subjects: [null],
        predicates: [null],
        objects
      })
      datasetEqual(ptr.dataset, expectedQuads)
    })
  })
  describe('deleteList', () => {
    it('should be a static method', () => {
      strictEqual(typeof Processor.deleteList, 'function')
    })
    it('should return the ptr', () => {
      const { predicates, ptr } = datasets.deleteList()
      const result = Processor.deleteList({ ptr, predicates })
      strictEqual(result, ptr)
    })
    it('should delete all quads related to the list', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteList()
      const result = Processor.deleteList({ ptr, predicates })
      datasetEqual(result.dataset, expectedQuads)
    })
  })
  describe('.execute', () => {
    it('should be a static method', () => {
      strictEqual(typeof Processor.execute, 'function')
    })
    it('should throw an error if an unknown operation is given', () => {
      const { ptr } = datasets.default()
      throws(() => {
        Processor.execute({ ptr, operation: 'test' })
      })
    })
    it('should support the add operation', () => {
      const { expectedQuads, graph, objects, predicates, ptr } = datasets.executeAddOut()
      Processor.execute({
        ptr,
        operation: 'add',
        start: 'subject',
        end: 'object',
        predicates,
        objects,
        graphs: [graph]
      })
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should support the addList operation', () => {
      const { expectedQuads, graph, items, predicates, ptr } = datasets.executeAddList()
      Processor.execute({
        ptr,
        operation: 'addList',
        predicates,
        items,
        graphs: [graph]
      })
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should support the delete operation', () => {
      const { expectedQuads, ptr, subjects } = datasets.deleteObjectSubject()
      Processor.execute({
        ptr,
        operation: 'delete',
        start: 'object',
        subjects,
        predicates: [null],
        objects: [null]
      })
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should support the deleteList operation', () => {
      const { expectedQuads, predicates, ptr } = datasets.deleteList()
      Processor.execute({
        ptr,
        operation: 'deleteList',
        predicates
      })
      datasetEqual(ptr.dataset, expectedQuads)
    })
    it('should support the isList operation', () => {
      const { ptr } = datasets.isList()
      const result = Processor.execute({
        ptr: ptr,
        operation: 'isList'
      })
      strictEqual(result, true)
    })
    it('should support the list operation', () => {
      const { ptr } = datasets.list()
      const result = Processor.execute({
        ptr,
        operation: 'list'
      })
      strictEqual(typeof result[Symbol.iterator], 'function')
      const items = [...result]
      strictEqual(items.length, 2)
      strictEqual(items[0].term.equals(ns.ex.end1), true)
      strictEqual(items[1].term.equals(ns.ex.end2), true)
    })
    it('should support the traverse operation', () => {
      const { predicates, ptr, expectedPtrs } = datasets.traverseOne()
      const result = Processor.execute({
        ptr,
        operation: 'traverse',
        quantifier: 'one',
        predicates
      })
      grapoiEqual(result, expectedPtrs)
    })
  })
  describe('.isList', () => {
    it('should be a static method', () => {
      strictEqual(typeof Processor.isList, 'function')
    })
    it('should return false if the given ptr is an any ptr', () => {
      const { ptr } = datasets.any()
      const result = Processor.isList({ ptr })
      strictEqual(result, false)
    })
    it('should return false if the given ptr is not a list', () => {
      const { ptr } = datasets.default()
      const result = Processor.isList({ ptr })
      strictEqual(result, false)
    })
    it('should return true if the given ptr is a list', () => {
      const { ptr } = datasets.isList()
      const result = Processor.isList({ ptr })
      strictEqual(result, true)
    })
    it('should return true if the given ptr is an empty list', () => {
      const { ptr } = datasets.isListEmpty()
      const result = Processor.isList({ ptr })
      strictEqual(result, true)
    })
  })
  describe('.list', () => {
    it('should return an iterator that loops over all items of the list', () => {
      const { ptr } = datasets.list()
      const result = Processor.list({ ptr })
      strictEqual(typeof result[Symbol.iterator], 'function')
      const items = [...result]
      strictEqual(items.length, 2)
      strictEqual(items[0].term.equals(ns.ex.end1), true)
      strictEqual(items[1].term.equals(ns.ex.end2), true)
    })
    it('should return undefined if the node is not a list', () => {
      const { ptr } = datasets.default()
      const result = Processor.list({ ptr })
      strictEqual(result, undefined)
    })
    it('should throw an error if rdf:first count is zero', () => {
      const { ptr } = datasets.listFirst0()
      throws(() => {
        Array.from(Processor.list({ ptr }))
      })
    })
    it('should throw an error if rdf:first count is two', () => {
      const { ptr } = datasets.listFirst2()
      throws(() => {
        Array.from(Processor.list({ ptr }))
      })
    })
    it('should throw an error if rdf:rest count is zero', () => {
      const { ptr } = datasets.listRest0()
      throws(() => {
        Array.from(Processor.list({ ptr }))
      })
    })
    it('should throw an error if rdf:rest count is two', () => {
      const { ptr } = datasets.listRest2()
      throws(() => {
        Array.from(Processor.list({ ptr }))
      })
    })
  })
  describe('.traverse', () => {
    it('should support quantifier one', () => {
      const { predicates, ptr, expectedPtrs } = datasets.traverseOne()
      const result = Processor.traverse({
        ptr,
        quantifier: 'one',
        predicates
      })
      grapoiEqual(result, expectedPtrs)
    })
    it('should support quantifier oneOrMore', () => {
      const { expectedQuads, predicates, ptr } = datasets.traverseOneOrMore()
      const result = Processor.traverse({
        ptr,
        quantifier: 'oneOrMore',
        predicates
      })
      grapoiEqual(result, expectedQuads)
    })
    it('should support quantifier zeroOrMore', () => {
      const { expectedQuads, predicates, ptr } = datasets.traverseZeroOrMore()
      const result = Processor.traverse({
        ptr,
        quantifier: 'zeroOrMore',
        predicates
      })
      grapoiEqual(result, expectedQuads)
    })
    it('should support quantifier zeroOrOne', () => {
      const { expectedQuads, predicates, ptr } = datasets.traverseZeroOrOne()
      const result = Processor.traverse({
        ptr,
        quantifier: 'zeroOrOne',
        predicates
      })
      grapoiEqual(result, expectedQuads)
    })
    it('should throw an error if an unknown quantifier is given', () => {
      const { predicates, ptr } = datasets.traverseOne()
      throws(() => {
        Processor.traverse({
          ptr,
          quantifier: 'test',
          predicates
        })
      })
    })
  })
  describe('.traverseMore', () => {
    it('should be a static method', () => {
      strictEqual(typeof Processor.traverseMore, 'function')
    })
    it('should return all expectedPtrs matching the current ptr or nested results', () => {
      const { expectedQuads, predicates, ptr } = datasets.traverseZeroOrMore()
      const result = Processor.traverseMore({
        ptrs: [ptr],
        end: 'object',
        start: 'subject',
        subjects: [null],
        predicates,
        objects: [null],
        graphs: [null]
      })
      grapoiEqual(result, expectedQuads)
    })
    it('should stop traversing if the start and end of an edge are the same', () => {
      const { expectedQuads, predicates, ptr } = datasets.traverseZeroOrMoreSelfRef()
      const result = Processor.traverseMore({
        ptrs: [ptr],
        end: 'object',
        start: 'subject',
        subjects: [null],
        predicates,
        objects: [null],
        graphs: [null]
      })
      grapoiEqual(result, expectedQuads)
    })
    it('should stop traversing if the end of an edge has been previously seen', () => {
      const { expectedQuads, predicates, ptr } = datasets.traverseZeroOrMoreSelfRef2()
      const result = Processor.traverseMore({
        ptrs: [ptr],
        end: 'object',
        start: 'subject',
        subjects: [null],
        predicates,
        objects: [null],
        graphs: [null]
      })
      grapoiEqual(result, expectedQuads)
    })
  })
  describe('.traverseOne', () => {
    it('should be a static method', () => {
      strictEqual(typeof Processor.traverseOne, 'function')
    })
    it('should loop over all subjects', () => {
      const result = []
      const { expectedQuads, ptr, subjects } = datasets.traverseOneSubject()
      Processor.traverseOne({
        ptr,
        end: 'subject',
        start: 'object',
        subjects,
        predicates: [null],
        objects: [null],
        graphs: [null],
        callback: ({ quad }) => result.push(quad)
      })
      datasetEqual(result, expectedQuads)
    })
    it('should loop over all predicates', () => {
      const result = []
      const { expectedQuads, predicates, ptr } = datasets.traverseOnePredicate()
      Processor.traverseOne({
        ptr,
        end: 'subject',
        start: 'object',
        subjects: [null],
        predicates,
        objects: [null],
        graphs: [null],
        callback: ({ quad }) => result.push(quad)
      })
      datasetEqual(result, expectedQuads)
    })
    it('should loop over all objects', () => {
      const result = []
      const { expectedQuads, objects, ptr } = datasets.traverseOneObject()
      Processor.traverseOne({
        ptr,
        end: 'object',
        start: 'subject',
        subjects: [null],
        predicates: [null],
        objects,
        graphs: [null],
        callback: ({ quad }) => result.push(quad)
      })
      datasetEqual(result, expectedQuads)
    })
    it('should use the ptr.term to match on position start', () => {
      const result = []
      const { expectedQuads, ptr } = datasets.traverseOnePtrTerm()
      Processor.traverseOne({
        ptr,
        end: 'object',
        start: 'subject',
        subjects: [null],
        predicates: [null],
        objects: [null],
        graphs: [null],
        callback: ({ quad }) => result.push(quad)
      })
      datasetEqual(result, expectedQuads)
    })
    it('should call the extend method with an edge argument', () => {
      const { dataset } = datasets.traverseOneSubject()
      const ptr = {
        dataset,
        extend: edge => strictEqual(edge instanceof Edge, true),
        term: null
      }
      Processor.traverseOne({
        ptr,
        end: 'object',
        start: 'subject',
        subjects: [null],
        predicates: [null],
        objects: [null],
        graphs: [null]
      })
    })
  })
})

================
File: test/support/createDataset.js
================
import TermMap from '@rdfjs/term-map'
import Edge from '../../Edge.js'
import Grapoi from '../../Grapoi.js'
import Path from '../../Path.js'
import PathList from '../../PathList.js'
import factory from './factory.js'
import * as ns from './namespaces.js'
function createPathDataset (data, {
  start = 'subject',
  end = 'object',
  term = ns.ex.start,
  graph,
  predicates = [ns.ex.propertyA, ns.ex.propertyB],
  add = true,
  expect,
  ...args
} = {}) {
  const quads = data.map(parts => factory.quad(...[...parts, graph]))
  const dataset = factory.dataset(add ? quads : [])
  const edges = quads.map(quad => new Edge({ dataset, end, quad, start }))
  const ptr = new Path({ dataset, factory, graph, term })
  const ptrs = edges.map(edge => new Path({ dataset, edges: [edge], factory, graph }))
  expect = expect || Object.keys(quads)
  const expectedPtrs = expect.map(index => ptrs[index])
  const expectedQuads = expect ? expect.map(index => quads[index]) : quads
  return {
    term,
    graph,
    quads,
    dataset,
    edges,
    ptr,
    expectedPtrs,
    expectedQuads,
    predicates,
    ...args
  }
}
function createPathListDataset (data, {
  start = 'subject',
  end = 'object',
  terms = [ns.ex.start1, ns.ex.start2],
  graphs = [null],
  predicates = [ns.ex.propertyA, ns.ex.propertyB],
  add = true,
  expect,
  ...args
} = {}) {
  const quads = []
  for (const graph of graphs) {
    const blankNodes = new TermMap()
    for (let parts of data) {
      parts = parts.map(part => {
        if (part.termType !== 'BlankNode') {
          return part
        }
        if (!blankNodes.has(part)) {
          blankNodes.set(part, factory.blankNode())
        }
        return blankNodes.get(part)
      })
      quads.push(factory.quad(...[...parts, graph || factory.defaultGraph()]))
    }
  }
  const dataset = factory.dataset(add ? quads : [])
  const edges = quads.map(quad => new Edge({ dataset, end, quad, start }))
  const ptrList = new PathList({ dataset, factory, graphs, terms })
  const grapoi = new Grapoi({ dataset, factory, graphs, terms })
  const ptrs = edges.map(edge => new Path({ dataset, edges: [edge], factory }))
  expect = expect || Object.keys(quads)
  const expectedPtrs = expect.map(index => ptrs[index])
  const expectedPtrList = new PathList({ factory, ptrs: expectedPtrs })
  const expectedQuads = expect ? expect.map(index => quads[index]) : quads
  return {
    terms,
    graphs,
    quads,
    dataset,
    edges,
    grapoi,
    ptrs,
    ptrList,
    expectedPtrs,
    expectedPtrList,
    expectedQuads,
    predicates,
    ...args
  }
}
export {
  createPathDataset,
  createPathListDataset
}

================
File: test/support/datasets.multi.js
================
import Edge from '../../Edge.js'
import Grapoi from '../../Grapoi.js'
import Path from '../../Path.js'
import PathList from '../../PathList.js'
import { createPathListDataset } from './createDataset.js'
import factory from './factory.js'
import * as ns from './namespaces.js'
const links = [
  factory.blankNode(),
  factory.blankNode(),
  factory.blankNode(),
  factory.blankNode(),
  factory.blankNode(),
  factory.blankNode(),
  factory.blankNode(),
  factory.blankNode()
]
const terms = {}
terms.ends = [ns.ex.end1, ns.ex.end2]
terms.items = [ns.ex.item1, ns.ex.item2]
terms.starts = [ns.ex.start1, ns.ex.start2]
terms.graphs = [ns.ex.graph1, ns.ex.graph2]
const triples = {}
triples.base = [
  [factory.namedNode(''), factory.namedNode('/propertyA'), links[0]],
  [links[0], factory.namedNode('/propertyB'), factory.namedNode('/end')],
  [ns.other(''), ns.other.propertyA, links[1]],
  [links[1], ns.other.propertyB, ns.other.end]
]
triples.based = [
  [ns.ex(''), ns.ex.propertyA, links[0]],
  [links[0], ns.ex.propertyB, ns.ex.end],
  [ns.other(''), ns.other.propertyA, links[1]],
  [links[1], ns.other.propertyB, ns.other.end]
]
triples.in = [
  [ns.ex.end1, ns.ex.propertyA, ns.ex.start1],
  [ns.ex.end1, ns.ex.propertyA, ns.ex.start2],
  [ns.ex.end1, ns.ex.propertyB, ns.ex.start1],
  [ns.ex.end1, ns.ex.propertyB, ns.ex.start2],
  [ns.ex.end2, ns.ex.propertyA, ns.ex.start1],
  [ns.ex.end2, ns.ex.propertyA, ns.ex.start2],
  [ns.ex.end2, ns.ex.propertyB, ns.ex.start1],
  [ns.ex.end2, ns.ex.propertyB, ns.ex.start2],
  [ns.ex.end3, ns.ex.propertyA, ns.ex.start2]
]
triples.inBlankNode = [
  [links[0], ns.ex.propertyA, ns.ex.start1],
  [links[0], ns.ex.propertyB, ns.ex.start1],
  [links[0], ns.ex.propertyA, ns.ex.start2],
  [links[0], ns.ex.propertyB, ns.ex.start2]
]
triples.inPath = [
  [links[0], ns.ex.propertyA, ns.ex.start1],
  [links[1], ns.ex.propertyA, ns.ex.start2],
  [links[2], ns.ex.propertyB, links[0]],
  [links[3], ns.ex.propertyB, links[1]],
  [ns.ex.end1, ns.ex.propertyA, links[2]],
  [ns.ex.end1, ns.ex.propertyB, links[2]],
  [ns.ex.end2, ns.ex.propertyA, links[2]],
  [ns.ex.end2, ns.ex.propertyB, links[2]],
  [ns.ex.end1, ns.ex.propertyA, links[3]],
  [ns.ex.end1, ns.ex.propertyB, links[3]],
  [ns.ex.end2, ns.ex.propertyA, links[3]],
  [ns.ex.end2, ns.ex.propertyB, links[3]]
]
triples.list2 = [
  [ns.ex.start1, ns.ex.propertyA, links[0]],
  [links[0], ns.rdf.first, ns.ex.item1],
  [links[0], ns.rdf.rest, links[1]],
  [links[1], ns.rdf.first, ns.ex.item2],
  [links[1], ns.rdf.rest, ns.rdf.nil],
  [ns.ex.start2, ns.ex.propertyB, links[2]],
  [links[2], ns.rdf.first, ns.ex.item1],
  [links[2], ns.rdf.rest, links[3]],
  [links[3], ns.rdf.first, ns.ex.item2],
  [links[3], ns.rdf.rest, ns.rdf.nil]
]
triples.list4 = [
  [ns.ex.start1, ns.ex.propertyA, links[0]],
  [links[0], ns.rdf.first, ns.ex.item1],
  [links[0], ns.rdf.rest, links[1]],
  [links[1], ns.rdf.first, ns.ex.item2],
  [links[1], ns.rdf.rest, ns.rdf.nil],
  [ns.ex.start1, ns.ex.propertyB, links[2]],
  [links[2], ns.rdf.first, ns.ex.item1],
  [links[2], ns.rdf.rest, links[3]],
  [links[3], ns.rdf.first, ns.ex.item2],
  [links[3], ns.rdf.rest, ns.rdf.nil],
  [ns.ex.start2, ns.ex.propertyA, links[4]],
  [links[4], ns.rdf.first, ns.ex.item1],
  [links[4], ns.rdf.rest, links[5]],
  [links[5], ns.rdf.first, ns.ex.item2],
  [links[5], ns.rdf.rest, ns.rdf.nil],
  [ns.ex.start2, ns.ex.propertyB, links[6]],
  [links[6], ns.rdf.first, ns.ex.item1],
  [links[6], ns.rdf.rest, links[7]],
  [links[7], ns.rdf.first, ns.ex.item2],
  [links[7], ns.rdf.rest, ns.rdf.nil]
]
triples.out = [
  [ns.ex.start1, ns.ex.propertyA, ns.ex.end1],
  [ns.ex.start1, ns.ex.propertyA, ns.ex.end2],
  [ns.ex.start1, ns.ex.propertyB, ns.ex.end1],
  [ns.ex.start1, ns.ex.propertyB, ns.ex.end2],
  [ns.ex.start2, ns.ex.propertyA, ns.ex.end1],
  [ns.ex.start2, ns.ex.propertyA, ns.ex.end2],
  [ns.ex.start2, ns.ex.propertyB, ns.ex.end1],
  [ns.ex.start2, ns.ex.propertyB, ns.ex.end2],
  [ns.ex.start2, ns.ex.propertyA, ns.ex.end3]
]
triples.outBlankNode = [
  [ns.ex.start1, ns.ex.propertyA, links[0]],
  [ns.ex.start1, ns.ex.propertyB, links[0]],
  [ns.ex.start2, ns.ex.propertyA, links[0]],
  [ns.ex.start2, ns.ex.propertyB, links[0]]
]
triples.outPath = [
  [ns.ex.start1, ns.ex.propertyA, links[0]],
  [ns.ex.start2, ns.ex.propertyB, links[1]],
  [links[0], ns.ex.propertyB, links[2]],
  [links[1], ns.ex.propertyB, links[3]],
  [links[2], ns.ex.propertyA, ns.ex.end1],
  [links[2], ns.ex.propertyA, ns.ex.end2],
  [links[2], ns.ex.propertyB, ns.ex.end1],
  [links[2], ns.ex.propertyB, ns.ex.end2],
  [links[3], ns.ex.propertyA, ns.ex.end1],
  [links[3], ns.ex.propertyA, ns.ex.end2],
  [links[3], ns.ex.propertyB, ns.ex.end1],
  [links[3], ns.ex.propertyB, ns.ex.end2]
]
triples.rebase = [
  [ns.ex(''), ns.ex.propertyA, links[0]],
  [links[0], ns.ex.propertyB, ns.ex.end],
  [ns.other(''), ns.other.propertyA, links[1]],
  [links[1], ns.other.propertyB, ns.other.end]
]
triples.rebased = [
  [ns.exCom(''), ns.exCom.propertyA, links[0]],
  [links[0], ns.exCom.propertyB, ns.exCom.end],
  [ns.other(''), ns.other.propertyA, links[1]],
  [links[1], ns.other.propertyB, ns.other.end]
]
triples.rebaseEmpty = [
  [factory.namedNode(''), ns.ex.propertyA, links[0]],
  [links[0], ns.ex.propertyB, factory.namedNode('end')]
]
triples.rebasedEmpty = [
  [ns.exCom(''), ns.ex.propertyA, links[0]],
  [links[0], ns.ex.propertyB, ns.exCom.end]
]
triples.rebaseRelative = [
  [factory.namedNode('http'), ns.ex.propertyA, links[0]],
  [links[0], ns.ex.propertyB, factory.namedNode('httpend')]
]
triples.rebasedRelative = [
  [ns.exCom(''), ns.ex.propertyA, links[0]],
  [links[0], ns.ex.propertyB, ns.exCom.end]
]
triples.replace = [
  [ns.ex(''), ns.ex.propertyA, links[0]],
  [links[0], ns.ex.propertyB, ns.ex.end],
  [ns.other(''), ns.other.propertyA, links[1]],
  [links[1], ns.other.propertyB, ns.other.end]
]
triples.replaced = [
  [ns.exCom(''), ns.ex.propertyA, links[0]],
  [links[0], ns.ex.propertyB, ns.ex.end],
  [ns.other(''), ns.other.propertyA, links[1]],
  [links[1], ns.other.propertyB, ns.other.end]
]
const multi = {}
multi.addIn = () => {
  return createPathListDataset(triples.in, {
    start: 'object',
    end: 'subject',
    add: false,
    expect: [0, 2, 4, 6, 1, 3, 5, 7],
    subjects: terms.ends,
    objects: terms.starts
  })
}
multi.addInNoSubject = () => {
  const { edges, expectedPtrs, ...others } = createPathListDataset(triples.inBlankNode, {
    start: 'object',
    end: 'subject',
    add: false,
    subjects: [links[0]],
    objects: terms.starts
  })
  const expectedGrapois = [
    new Grapoi({ ptrs: [expectedPtrs[0]] }),
    new Grapoi({ ptrs: [expectedPtrs[1]] }),
    new Grapoi({ ptrs: [expectedPtrs[2]] }),
    new Grapoi({ ptrs: [expectedPtrs[3]] })
  ]
  return { ...others, edges, expectedGrapois, expectedPtrs }
}
multi.addInGraphs = () => {
  return createPathListDataset(triples.in, {
    start: 'object',
    end: 'subject',
    add: false,
    expect: [0, 2, 4, 6, 1, 3, 5, 7, 9, 11, 13, 15, 10, 12, 14, 16],
    subjects: terms.ends,
    objects: terms.starts,
    graphs: terms.graphs
  })
}
multi.addInPath = () => {
  const { edges, ...others } = createPathListDataset(triples.inPath, {
    start: 'object',
    end: 'subject',
    add: false,
    subjects: terms.ends
  })
  const ptrs = [
    new Path({ edges: [edges[0], edges[2]], factory }),
    new Path({ edges: [edges[1], edges[3]], factory })
  ]
  const ptrList = new PathList({ factory, ptrs })
  const grapoi = new Grapoi({ factory, ptrs })
  const expectedPaths = [
    [new Path({ edges: [edges[0], edges[2], edges[4]] })],
    [new Path({ edges: [edges[0], edges[2], edges[5]] })],
    [new Path({ edges: [edges[0], edges[2], edges[6]] })],
    [new Path({ edges: [edges[0], edges[2], edges[7]] })],
    [new Path({ edges: [edges[1], edges[3], edges[8]] })],
    [new Path({ edges: [edges[1], edges[3], edges[9]] })],
    [new Path({ edges: [edges[1], edges[3], edges[10]] })],
    [new Path({ edges: [edges[1], edges[3], edges[11]] })]
  ]
  const expectedPtrLists = [
    new PathList({ ptrs: expectedPaths[0] }),
    new PathList({ ptrs: expectedPaths[1] }),
    new PathList({ ptrs: expectedPaths[2] }),
    new PathList({ ptrs: expectedPaths[3] }),
    new PathList({ ptrs: expectedPaths[4] }),
    new PathList({ ptrs: expectedPaths[5] }),
    new PathList({ ptrs: expectedPaths[6] }),
    new PathList({ ptrs: expectedPaths[7] })
  ]
  const expectedGrapois = [
    new Grapoi({ ptrs: expectedPaths[0] }),
    new Grapoi({ ptrs: expectedPaths[1] }),
    new Grapoi({ ptrs: expectedPaths[2] }),
    new Grapoi({ ptrs: expectedPaths[3] }),
    new Grapoi({ ptrs: expectedPaths[4] }),
    new Grapoi({ ptrs: expectedPaths[5] }),
    new Grapoi({ ptrs: expectedPaths[6] }),
    new Grapoi({ ptrs: expectedPaths[7] })
  ]
  return { ...others, edges, expectedGrapois, expectedPtrLists, grapoi, ptrList }
}
multi.addList = () => {
  return createPathListDataset(triples.list4, {
    add: false,
    items: terms.items
  })
}
multi.addListEmpty = () => {
  return createPathListDataset([
    [ns.ex.start1, ns.ex.propertyA, ns.rdf.nil],
    [ns.ex.start1, ns.ex.propertyB, ns.rdf.nil],
    [ns.ex.start2, ns.ex.propertyA, ns.rdf.nil],
    [ns.ex.start2, ns.ex.propertyB, ns.rdf.nil]
  ], {
    add: false,
    items: []
  })
}
multi.addListGraphs = () => {
  return createPathListDataset(triples.list4, {
    add: false,
    items: terms.items,
    graphs: terms.graphs
  })
}
multi.addOut = () => {
  return createPathListDataset(triples.out, {
    add: false,
    expect: [0, 1, 2, 3, 4, 5, 6, 7],
    objects: terms.ends
  })
}
multi.addOutNoObject = () => {
  const { edges, expectedPtrs, ...others } = createPathListDataset(triples.outBlankNode, {
    add: false,
    subjects: terms.starts,
    objects: [links[0]]
  })
  const expectedGrapois = [
    new Grapoi({ ptrs: [expectedPtrs[0]] }),
    new Grapoi({ ptrs: [expectedPtrs[1]] }),
    new Grapoi({ ptrs: [expectedPtrs[2]] }),
    new Grapoi({ ptrs: [expectedPtrs[3]] })
  ]
  return { ...others, edges, expectedGrapois, expectedPtrs }
}
multi.addOutGraphs = () => {
  return createPathListDataset(triples.out, {
    add: false,
    expect: [0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16],
    objects: terms.ends,
    graphs: terms.graphs
  })
}
multi.addOutPath = () => {
  const { edges, ...others } = createPathListDataset(triples.outPath, {
    add: false,
    objects: terms.ends
  })
  const ptrs = [
    new Path({ edges: [edges[0], edges[2]], factory }),
    new Path({ edges: [edges[1], edges[3]], factory })
  ]
  const ptrList = new PathList({ factory, ptrs })
  const grapoi = new Grapoi({ factory, ptrs })
  const expectedPaths = [
    [new Path({ edges: [edges[0], edges[2], edges[4]] })],
    [new Path({ edges: [edges[0], edges[2], edges[5]] })],
    [new Path({ edges: [edges[0], edges[2], edges[6]] })],
    [new Path({ edges: [edges[0], edges[2], edges[7]] })],
    [new Path({ edges: [edges[1], edges[3], edges[8]] })],
    [new Path({ edges: [edges[1], edges[3], edges[9]] })],
    [new Path({ edges: [edges[1], edges[3], edges[10]] })],
    [new Path({ edges: [edges[1], edges[3], edges[11]] })]
  ]
  const expectedPtrLists = [
    new PathList({ ptrs: expectedPaths[0] }),
    new PathList({ ptrs: expectedPaths[1] }),
    new PathList({ ptrs: expectedPaths[2] }),
    new PathList({ ptrs: expectedPaths[3] }),
    new PathList({ ptrs: expectedPaths[4] }),
    new PathList({ ptrs: expectedPaths[5] }),
    new PathList({ ptrs: expectedPaths[6] }),
    new PathList({ ptrs: expectedPaths[7] })
  ]
  const expectedGrapois = [
    new Grapoi({ ptrs: expectedPaths[0] }),
    new Grapoi({ ptrs: expectedPaths[1] }),
    new Grapoi({ ptrs: expectedPaths[2] }),
    new Grapoi({ ptrs: expectedPaths[3] }),
    new Grapoi({ ptrs: expectedPaths[4] }),
    new Grapoi({ ptrs: expectedPaths[5] }),
    new Grapoi({ ptrs: expectedPaths[6] }),
    new Grapoi({ ptrs: expectedPaths[7] })
  ]
  return { ...others, edges, expectedGrapois, expectedPtrLists, grapoi, ptrList }
}
multi.any = () => {
  return createPathListDataset([], { terms: [null] })
}
multi.base = () => {
  const { ...others } = createPathListDataset(triples.base, { terms: [ns.ex('')] })
  const expectedTerm = ns.ex('')
  const expectedGrapoi = new Grapoi({
    dataset: factory.dataset(triples.based.map(parts => factory.quad(...parts))),
    term: expectedTerm
  })
  return { expectedGrapoi, expectedTerm, ...others }
}
multi.best = () => {
  const { dataset, ...others } = createPathListDataset(triples.inBlankNode, {
    subjects: [ns.ex.start1, ns.ex.start1]
  })
  const expectedGrapoi = new Grapoi({ dataset, term: ns.ex.start2 })
  return { expectedGrapoi, ...others }
}
multi.clonePtrs = () => {
  const { ptrList, ptrs, ...others } = createPathListDataset(triples.out)
  const emptyPathList = new PathList({
    dataset: ptrList.dataset,
    factory: ptrList.factory,
    ptrs: []
  })
  return { ptrList: emptyPathList, ptrs, ...others }
}
multi.constructorGraphs = () => {
  return createPathListDataset([], {
    graphs: [ns.ex.graph1, ns.ex.graph2]
  })
}
multi.constructorPtrsVsTerms = () => {
  const { ...others } = createPathListDataset([])
  const terms = [ns.ex.deadEnd1, ns.ex.deadEnd2]
  return { ...others, terms }
}
multi.default = () => {
  return createPathListDataset([])
}
multi.deleteIn = () => {
  return createPathListDataset([
    ...triples.in,
    [ns.ex.deadEnd, ns.ex.propertyC, ns.ex.start2]
  ], {
    start: 'object',
    end: 'subject',
    expect: [9]
  })
}
multi.deleteInSubjects = () => {
  return createPathListDataset([
    ...triples.in,
    [ns.ex.deadEnd, ns.ex.propertyC, ns.ex.start2]
  ], {
    start: 'object',
    end: 'subject',
    expect: [8, 9],
    subjects: terms.ends
  })
}
multi.deleteList = () => {
  return createPathListDataset(triples.list2, {
    expect: []
  })
}
multi.deleteOut = () => {
  return createPathListDataset([
    ...triples.out,
    [ns.ex.start2, ns.ex.propertyC, ns.ex.deadEnd]
  ], {
    start: 'object',
    end: 'subject',
    expect: [9]
  })
}
multi.deleteOutObjects = () => {
  return createPathListDataset([
    ...triples.out,
    [ns.ex.start2, ns.ex.propertyC, ns.ex.deadEnd]
  ], {
    start: 'object',
    end: 'subject',
    expect: [8, 9],
    objects: terms.ends
  })
}
multi.empty = () => {
  return createPathListDataset([], { terms: [] })
}
multi.execute = () => {
  const { dataset, edges, ...others } = createPathListDataset([
    [ns.ex.start1, ns.ex.propertyA, ns.ex.end1],
    [ns.ex.end1, ns.ex.propertyB, ns.ex.end2],
    [ns.ex.start2, ns.ex.propertyA, ns.ex.end3],
    [ns.ex.start2, ns.ex.propertyC, ns.ex.deadEnd]
  ])
  const ptrs = [
    new Path({ edges: [edges[0]] }),
    new Path({ edges: [edges[0], edges[1]] }),
    new Path({ edges: [edges[2]] })
  ]
  const expectedPtrList = new PathList({ ptrs })
  const expectedGrapoi = new Grapoi({ ptrs })
  return { ...others, dataset, edges, expectedGrapoi, expectedPtrList }
}
multi.executeAll = () => {
  const { dataset, predicates, quads, ...others } = createPathListDataset([
    [ns.ex.start1, ns.ex.propertyA, links[0]],
    [ns.ex.end1, ns.ex.propertyB, links[0]],
    [ns.ex.start2, ns.ex.propertyA, links[1]],
    [ns.ex.end2, ns.ex.propertyB, links[1]],
    [ns.ex.start2, ns.ex.propertyA, ns.ex.deadEnd]
  ])
  const ptrs = [
    new Path({
      edges: [
        new Edge({ dataset, quad: quads[0], start: 'subject', end: 'object' }),
        new Edge({ dataset, quad: quads[1], start: 'object', end: 'subject' })
      ]
    }),
    new Path({
      edges: [
        new Edge({ dataset, quad: quads[2], start: 'subject', end: 'object' }),
        new Edge({ dataset, quad: quads[3], start: 'object', end: 'subject' })
      ]
    })
  ]
  const expectedPtrList = new PathList({ ptrs })
  const expectedGrapoi = new Grapoi({ ptrs })
  const instructions = [{
    start: 'subject',
    end: 'object',
    predicates: [predicates[0]]
  }, {
    start: 'object',
    end: 'subject',
    predicates: [predicates[1]]
  }]
  return { ...others, dataset, expectedGrapoi, expectedPtrList, instructions, predicates, quads }
}
multi.in = () => {
  return createPathListDataset([
    ...triples.in,
    [ns.ex.deadEnd, ns.ex.propertyC, ns.ex.start2]
  ], {
    start: 'object',
    end: 'subject',
    expect: [0, 4, 2, 6, 1, 5, 8, 3, 7]
  })
}
multi.inSubjects = () => {
  return createPathListDataset([
    ...triples.in,
    [ns.ex.deadEnd, ns.ex.propertyC, ns.ex.start2]
  ], {
    start: 'object',
    end: 'subject',
    expect: [0, 2, 4, 6, 1, 3, 5, 7],
    subjects: terms.ends
  })
}
multi.iterator = () => {
  const { dataset, terms, ...others } = createPathListDataset(triples.out)
  const expectedPtrLists = terms.map(term => new PathList({
    dataset,
    factory,
    terms: [term]
  }))
  const expectedGrapois = terms.map(term => new PathList({
    dataset,
    factory,
    terms: [term]
  }))
  return { ...others, expectedGrapois, expectedPtrLists }
}
multi.hasIn = () => {
  return createPathListDataset(triples.in, {
    start: 'object',
    end: 'object',
    expect: [0, 4, 2, 6, 1, 5, 8, 3, 7]
  })
}
multi.hasInSubject = () => {
  return createPathListDataset(triples.in, {
    start: 'object',
    end: 'object',
    expect: [0, 2, 4, 6, 1, 3, 5, 7],
    subjects: terms.ends
  })
}
multi.hasOut = () => {
  return createPathListDataset(triples.out, {
    start: 'subject',
    end: 'subject',
    expect: [0, 1, 2, 3, 4, 5, 8, 6, 7]
  })
}
multi.hasOutObjects = () => {
  return createPathListDataset(triples.out, {
    start: 'subject',
    end: 'subject',
    expect: [0, 1, 2, 3, 4, 5, 6, 7],
    objects: terms.ends
  })
}
multi.list = () => {
  const { dataset, edges, ...others } = createPathListDataset(triples.list2)
  const ptrList = new PathList({ dataset, factory, terms: [edges[0].term] })
  const grapoi = new Grapoi({ dataset, factory, terms: [edges[0].term] })
  return { ...others, dataset, edges, grapoi, items: terms.items, ptrList }
}
multi.out = () => {
  return createPathListDataset([
    ...triples.out,
    [ns.ex.start2, ns.ex.propertyC, ns.ex.deadEnd]
  ], {
    expect: [0, 1, 2, 3, 4, 5, 8, 6, 7]
  })
}
multi.outObjects = () => {
  return createPathListDataset([
    ...triples.out,
    [ns.ex.start2, ns.ex.propertyC, ns.ex.deadEnd]
  ], {
    expect: [0, 1, 2, 3, 4, 5, 6, 7],
    objects: terms.ends
  })
}
multi.quads = () => {
  const { edges, ...others } = createPathListDataset([
    [ns.ex.start1, ns.ex.propertyA, ns.ex.node1],
    [ns.ex.node1, ns.ex.propertyB, ns.ex.end1],
    [ns.ex.start2, ns.ex.propertyA, ns.ex.node2],
    [ns.ex.node2, ns.ex.propertyB, ns.ex.end2]
  ])
  const ptrList = new PathList({
    ptrs: [
      new Path({ edges: [edges[0], edges[1]] }),
      new Path({ edges: [edges[2], edges[3]] })
    ]
  })
  return { ...others, ptrList }
}
multi.rebase = () => {
  const { ...others } = createPathListDataset(triples.rebase, { terms: [ns.ex('')] })
  const expectedTerm = ns.exCom('')
  const expectedGrapoi = new Grapoi({
    dataset: factory.dataset(triples.rebased.map(parts => factory.quad(...parts))),
    term: expectedTerm
  })
  return { expectedGrapoi, expectedTerm, ...others }
}
multi.rebaseEmpty = () => {
  const { ...others } = createPathListDataset(triples.rebaseEmpty, { terms: [factory.namedNode('')] })
  const expectedTerm = ns.exCom('')
  const expectedGrapoi = new Grapoi({
    dataset: factory.dataset(triples.rebasedEmpty.map(parts => factory.quad(...parts))),
    term: expectedTerm
  })
  return { expectedGrapoi, expectedTerm, ...others }
}
multi.rebaseRelative = () => {
  const { ...others } = createPathListDataset(triples.rebaseRelative, { terms: [factory.namedNode('http')] })
  const expectedTerm = ns.exCom('')
  const expectedGrapoi = new Grapoi({
    dataset: factory.dataset(triples.rebasedRelative.map(parts => factory.quad(...parts))),
    term: expectedTerm
  })
  return { expectedGrapoi, expectedTerm, ...others }
}
multi.replace = () => {
  const { ...others } = createPathListDataset(triples.replace, { terms: [ns.ex('')] })
  const expectedTerm = ns.exCom('')
  const expectedGrapoi = new Grapoi({
    dataset: factory.dataset(triples.replaced.map(parts => factory.quad(...parts))),
    term: expectedTerm
  })
  return { expectedGrapoi, expectedTerm, ...others }
}
multi.score = () => {
  const { dataset, ...others } = createPathListDataset(triples.inBlankNode, {
    subjects: [ns.ex.start1, ns.ex.start1]
  })
  const expectedGrapoi = new Grapoi({ dataset, term: [ns.ex.start2, ns.ex.start1] })
  return { expectedGrapoi, ...others }
}
multi.trim = () => {
  const { dataset, edges, ...others } = createPathListDataset(triples.outPath)
  const ptrList = new PathList({
    factory,
    ptrs: [
      new Path({ edges: [edges[0], edges[2], edges[4]] }),
      new Path({ edges: [edges[0], edges[2], edges[5]] }),
      new Path({ edges: [edges[0], edges[2], edges[6]] }),
      new Path({ edges: [edges[0], edges[2], edges[7]] }),
      new Path({ edges: [edges[1], edges[3], edges[8]] }),
      new Path({ edges: [edges[1], edges[3], edges[9]] }),
      new Path({ edges: [edges[1], edges[3], edges[10]] }),
      new Path({ edges: [edges[1], edges[3], edges[11]] })
    ]
  })
  const expectedPtrList = new PathList({
    factory,
    ptrs: [
      new Path({ dataset, graph: edges[4].graph, term: edges[4].term }),
      new Path({ dataset, graph: edges[5].graph, term: edges[5].term }),
      new Path({ dataset, graph: edges[6].graph, term: edges[6].term }),
      new Path({ dataset, graph: edges[7].graph, term: edges[7].term }),
      new Path({ dataset, graph: edges[8].graph, term: edges[8].term }),
      new Path({ dataset, graph: edges[9].graph, term: edges[9].term }),
      new Path({ dataset, graph: edges[10].graph, term: edges[10].term }),
      new Path({ dataset, graph: edges[11].graph, term: edges[11].term })
    ]
  })
  return { ...others, dataset, edges, expectedPtrList, ptrList }
}
multi.clone = multi.out
multi.constructorPtrs = multi.out
multi.filter = multi.out
multi.map = multi.out
export default multi

================
File: test/support/datasets.single.js
================
import Edge from '../../Edge.js'
import Path from '../../Path.js'
import { createPathDataset } from './createDataset.js'
import factory from './factory.js'
import * as ns from './namespaces.js'
const links = [
  factory.blankNode(),
  factory.blankNode(),
  factory.blankNode(),
  factory.blankNode()
]
const terms = {}
terms.ends = [ns.ex.end1, ns.ex.end2]
terms.graph = ns.ex.graph
const triples = {}
triples.graph = [
  [ns.ex.start, ns.ex.propertyA, ns.ex.node, ns.ex.otherGraph],
  [ns.ex.node, ns.ex.propertyB, ns.ex.end, terms.graph]
]
triples.in = [
  [ns.ex.end1, ns.ex.propertyA, ns.ex.start],
  [ns.ex.end1, ns.ex.propertyB, ns.ex.start],
  [ns.ex.end2, ns.ex.propertyA, ns.ex.start],
  [ns.ex.end2, ns.ex.propertyB, ns.ex.start]
]
triples.in3 = [
  [ns.ex.end1, ns.ex.propertyA, ns.ex.start],
  [ns.ex.end2, ns.ex.propertyA, ns.ex.start],
  [ns.ex.end1, ns.ex.propertyB, ns.ex.start],
  [ns.ex.end2, ns.ex.propertyB, ns.ex.start],
  [ns.ex.end3, ns.ex.propertyB, ns.ex.start],
  [ns.ex.deadEnd, ns.ex.propertyC, ns.ex.start]
]
triples.list = [
  [ns.ex.start, ns.ex.list, links[0]],
  [links[0], ns.rdf.first, ns.ex.end1],
  [links[0], ns.rdf.rest, links[1]],
  [links[1], ns.rdf.first, ns.ex.end2],
  [links[1], ns.rdf.rest, ns.rdf.nil]
]
triples.list2 = [
  [ns.ex.start, ns.ex.propertyA, links[0]],
  [links[0], ns.rdf.first, ns.ex.item1],
  [links[0], ns.rdf.rest, links[1]],
  [links[1], ns.rdf.first, ns.ex.item2],
  [links[1], ns.rdf.rest, ns.rdf.nil],
  [ns.ex.start, ns.ex.propertyB, links[2]],
  [links[2], ns.rdf.first, ns.ex.item1],
  [links[2], ns.rdf.rest, links[3]],
  [links[3], ns.rdf.first, ns.ex.item2],
  [links[3], ns.rdf.rest, ns.rdf.nil]
]
triples.listEmpty2 = [
  [ns.ex.start, ns.ex.propertyA, ns.rdf.nil],
  [ns.ex.start, ns.ex.propertyB, ns.rdf.nil]
]
triples.listFirst0 = [
  [ns.ex.start, ns.ex.propertyA, links[0]],
  [links[0], ns.rdf.first, ns.ex.end1],
  [links[0], ns.rdf.rest, links[1]],
  [links[1], ns.rdf.rest, ns.rdf.nil]
]
triples.listFirst2 = [
  [ns.ex.start, ns.ex.propertyA, links[0]],
  [links[0], ns.rdf.first, ns.ex.end1],
  [links[0], ns.rdf.rest, links[1]],
  [links[1], ns.rdf.first, ns.ex.end2a],
  [links[1], ns.rdf.first, ns.ex.end2b],
  [links[1], ns.rdf.rest, ns.rdf.nil]
]
triples.listRest0 = [
  [ns.ex.start, ns.ex.propertyA, links[0]],
  [links[0], ns.rdf.first, ns.ex.end1]
]
triples.listRest2 = [
  [ns.ex.start, ns.ex.propertyA, links[0]],
  [links[0], ns.rdf.first, ns.ex.end1],
  [links[0], ns.rdf.rest, links[1]],
  [links[0], ns.rdf.rest, ns.rdf.nil]
]
triples.out = [
  [ns.ex.start, ns.ex.propertyA, ns.ex.end1],
  [ns.ex.start, ns.ex.propertyA, ns.ex.end2],
  [ns.ex.start, ns.ex.propertyB, ns.ex.end1],
  [ns.ex.start, ns.ex.propertyB, ns.ex.end2]
]
triples.out3 = [
  [ns.ex.start, ns.ex.propertyA, ns.ex.end1],
  [ns.ex.start, ns.ex.propertyA, ns.ex.end2],
  [ns.ex.start, ns.ex.propertyB, ns.ex.end1],
  [ns.ex.start, ns.ex.propertyB, ns.ex.end2],
  [ns.ex.start, ns.ex.propertyB, ns.ex.end3],
  [ns.ex.start, ns.ex.propertyC, ns.ex.deadEnd]
]
triples.path = [
  [ns.ex.start, ns.ex.propertyA, ns.ex.node],
  [ns.ex.node, ns.ex.propertyB, ns.ex.end]
]
const single = {}
single.addIn = () => {
  return createPathDataset(triples.in, {
    start: 'object',
    end: 'subject',
    add: false,
    subjects: terms.ends
  })
}
single.addInGraph = () => {
  return createPathDataset(triples.in, {
    start: 'object',
    end: 'subject',
    add: false,
    graph: terms.graph,
    subjects: terms.ends
  })
}
single.addList = () => {
  return createPathDataset(triples.list2, {
    add: false,
    items: [ns.ex.item1, ns.ex.item2]
  })
}
single.addListAny = () => {
  return createPathDataset([], {
    term: null,
    add: false,
    items: []
  })
}
single.addListEmpty = () => {
  return createPathDataset(triples.listEmpty2, {
    add: false,
    items: []
  })
}
single.addListGraph = () => {
  return createPathDataset(triples.list2, {
    add: false,
    graph: terms.graph,
    items: [ns.ex.item1, ns.ex.item2]
  })
}
single.addOut = () => {
  return createPathDataset(triples.out, {
    add: false,
    objects: terms.ends
  })
}
single.addOutGraph = () => {
  return createPathDataset(triples.out, {
    add: false,
    graph: terms.graph,
    objects: terms.ends
  })
}
single.addOutNoFactory = () => {
  const { ptr, ...others } = createPathDataset(triples.out, {
    add: false,
    objects: terms.ends
  })
  delete ptr.factory
  return { ...others, ptr }
}
single.any = () => {
  return createPathDataset([], {
    term: null
  })
}
single.deleteIn = () => {
  return createPathDataset(triples.in3, {
    expect: [4, 5],
    subjects: terms.ends
  })
}
single.default = () => {
  return createPathDataset([])
}
single.defaultGraph = () => {
  return createPathDataset([], {
    graph: terms.graph
  })
}
single.deleteList = () => {
  return createPathDataset([
    ...triples.list2,
    [ns.ex.start, ns.ex.propertyC, ns.ex.deadEnd]
  ], {
    expect: [10]
  })
}
single.deleteListEmpty = () => {
  return createPathDataset([
    ...triples.listEmpty2,
    [ns.ex.start, ns.ex.propertyC, ns.ex.deadEnd]
  ], {
    expect: [2]
  })
}
single.deleteListFirst0 = () => {
  return createPathDataset(triples.listFirst0, {
    expect: []
  })
}
single.deleteListFirst2 = () => {
  return createPathDataset(triples.listFirst2, {
    expect: []
  })
}
single.deleteListRest0 = () => {
  return createPathDataset(triples.listRest0, {
    expect: []
  })
}
single.deleteListRest2 = () => {
  return createPathDataset(triples.listRest2, {
    expect: []
  })
}
single.deleteObjectSubject = () => {
  return createPathDataset([
    ...triples.in,
    [ns.ex.deadEnd, ns.ex.propertyC, ns.ex.start]
  ], {
    start: 'object',
    end: 'subject',
    expect: [4],
    subjects: terms.ends
  })
}
single.deleteOut = () => {
  return createPathDataset(triples.out3, {
    start: 'object',
    end: 'subject',
    expect: [4, 5],
    objects: terms.ends
  })
}
single.deleteSubjectObject = () => {
  return createPathDataset([
    ...triples.out,
    [ns.ex.start, ns.ex.propertyC, ns.ex.deadEnd]
  ], {
    expect: [4],
    objects: terms.ends
  })
}
single.deleteSubjectPredicate = () => {
  return createPathDataset([
    ...triples.out,
    [ns.ex.start, ns.ex.propertyC, ns.ex.deadEnd]
  ], {
    expect: [4]
  })
}
single.extend = () => {
  const { edges, ...others } = single.out()
  const ptr = new Path({ edges: [edges[0]] })
  const expectedQuads = new Path({ edges: [edges[0], edges[1]] })
  return { ...others, edges, expectedQuads, ptr }
}
single.extendGraph = () => {
  return createPathDataset(triples.out, {
    graph: terms.graph
  })
}
single.extendGraphNull = () => {
  return createPathDataset(triples.out, {
    graph: null
  })
}
single.graphEdges = () => {
  const { edges, ...others } = createPathDataset(triples.graph)
  const ptr = new Path({ edges })
  return { ...others, edges, ptr }
}
single.graphEdgesNull = () => {
  const { edges, ...others } = createPathDataset(triples.graph)
  const ptr = new Path({ edges, graph: null })
  return { ...others, edges, ptr }
}
single.hasIn = () => {
  return createPathDataset(triples.in3, {
    expect: [0, 1, 2, 3, 4],
    start: 'object',
    end: 'object'
  })
}
single.hasInGraph = () => {
  return createPathDataset([
    ...triples.in3,
    [...triples.in3[0], ns.ex.otherGraph]
  ], {
    expect: [0, 1, 2, 3, 4],
    start: 'object',
    end: 'object',
    graph: terms.graph
  })
}
single.hasInSubjects = () => {
  return createPathDataset(triples.in3, {
    expect: [0, 2, 1, 3],
    start: 'object',
    end: 'object',
    subjects: terms.ends
  })
}
single.hasOut = () => {
  return createPathDataset(triples.out3, {
    expect: [0, 1, 2, 3, 4],
    start: 'subject',
    end: 'subject'
  })
}
single.hasOutGraph = () => {
  return createPathDataset([
    ...triples.out3,
    [...triples.out3[0], ns.ex.otherGraph]
  ], {
    expect: [0, 1, 2, 3, 4],
    start: 'subject',
    end: 'subject',
    graph: terms.graph
  })
}
single.hasOutObjects = () => {
  return createPathDataset(triples.out3, {
    expect: [0, 1, 2, 3],
    start: 'subject',
    end: 'subject',
    objects: terms.ends
  })
}
single.in = () => {
  return createPathDataset(triples.in3, {
    expect: [0, 1, 2, 3, 4],
    start: 'object',
    end: 'subject'
  })
}
single.inGraph = () => {
  return createPathDataset([
    ...triples.in3,
    [...triples.in3[0], ns.ex.otherGraph]
  ], {
    expect: [0, 1, 2, 3, 4],
    start: 'object',
    end: 'subject',
    graph: terms.graph
  })
}
single.inSubjects = () => {
  return createPathDataset(triples.in3, {
    expect: [0, 2, 1, 3],
    start: 'object',
    end: 'subject',
    subjects: terms.ends
  })
}
single.isList = () => {
  const { edges, ...others } = createPathDataset(triples.list)
  const ptr = new Path({ edges: [edges[0]] })
  return { ...others, edges, ptr }
}
single.isListEmpty = () => {
  const { edges, ...others } = createPathDataset([
    [ns.ex.start, ns.ex.list, ns.rdf.nil]
  ])
  const ptr = new Path({ edges: [edges[0]] })
  return { ...others, edges, ptr }
}
single.length = () => {
  const { dataset, quads, ...others } = createPathDataset(triples.path)
  const ptr = new Path({
    dataset,
    edges: [
      new Edge({ quad: quads[0], start: 'subject', end: 'object' }),
      new Edge({ quad: quads[1], start: 'subject', end: 'object' })
    ]
  })
  return { ...others, dataset, ptr }
}
single.list = () => {
  const { edges, ...others } = createPathDataset(triples.list)
  const ptr = new Path({ edges: [edges[0]] })
  return { ...others, edges, ptr }
}
single.listEmpty = () => {
  const { edges, ...others } = createPathDataset([
    [ns.ex.start, ns.ex.list, ns.rdf.nil]
  ])
  const ptr = new Path({ edges: [edges[0]] })
  return { ...others, edges, ptr }
}
single.listFirst0 = () => {
  const { edges, ...others } = createPathDataset(triples.listFirst0)
  const ptr = new Path({ edges: [edges[0]] })
  return { ...others, edges, ptr }
}
single.listFirst2 = () => {
  const { edges, ...others } = createPathDataset(triples.listFirst2)
  const ptr = new Path({ edges: [edges[0]] })
  return { ...others, edges, ptr }
}
single.listRest0 = () => {
  const { edges, ...others } = createPathDataset(triples.listRest0)
  const ptr = new Path({ edges: [edges[0]] })
  return { ...others, edges, ptr }
}
single.listRest2 = () => {
  const { edges, ...others } = createPathDataset(triples.listRest2)
  const ptr = new Path({ edges: [edges[0]] })
  return { ...others, edges, ptr }
}
single.nodes = () => {
  const { dataset, quads, ...others } = createPathDataset(triples.path)
  const ptr = new Path({
    edges: [
      new Edge({ dataset, quad: quads[0], start: 'subject', end: 'object' }),
      new Edge({ dataset, quad: quads[1], start: 'subject', end: 'object' })
    ]
  })
  return { ...others, dataset, ptr }
}
single.out = () => {
  return createPathDataset(triples.out3, {
    expect: [0, 1, 2, 3, 4]
  })
}
single.outGraph = () => {
  return createPathDataset([
    ...triples.out3,
    [...triples.out3[0], ns.ex.otherGraph]
  ], {
    expect: [0, 1, 2, 3, 4],
    graph: terms.graph
  })
}
single.outObjects = () => {
  return createPathDataset(triples.out3, {
    expect: [0, 1, 2, 3],
    objects: terms.ends
  })
}
single.traverseOneObject = () => {
  return createPathDataset(triples.out3, {
    expect: [0, 1, 2, 3],
    objects: terms.ends
  })
}
single.traverseOneOrMore = () => {
  const { edges, ...others } = createPathDataset([
    [ns.ex.start, ns.ex.propertyA, ns.ex.end1],
    [ns.ex.end1, ns.ex.propertyB, ns.ex.end2],
    [ns.ex.start, ns.ex.propertyC, ns.ex.deadEnd]
  ])
  const expectedQuads = [
    new Path({ edges: [edges[0]] }),
    new Path({ edges: [edges[0], edges[1]] })
  ]
  return { ...others, edges, expectedQuads }
}
single.traverseOnePtrTerm = () => {
  return createPathDataset([
    ...triples.out3,
    [ns.ex.deadEnd, ns.ex.propertyA, ns.ex.end1]
  ], {
    expect: [0, 1, 2, 3, 4, 5]
  })
}
single.traverseOneSubject = () => {
  return createPathDataset(triples.in3, {
    expect: [0, 1, 2, 3],
    subjects: terms.ends
  })
}
single.traverseZeroOrMore = () => {
  const { dataset, edges, ...others } = createPathDataset([
    [ns.ex.start, ns.ex.propertyA, ns.ex.end1],
    [ns.ex.end1, ns.ex.propertyB, ns.ex.end2],
    [ns.ex.start, ns.ex.propertyC, ns.ex.deadEnd]
  ])
  const expectedQuads = [
    new Path({ dataset, term: edges[0].startTerm }),
    new Path({ edges: [edges[0]] }),
    new Path({ edges: [edges[0], edges[1]] })
  ]
  return { ...others, dataset, edges, expectedQuads }
}
single.traverseZeroOrMoreSelfRef = () => {
  const { dataset, edges, ...others } = createPathDataset([
    [ns.ex.start, ns.ex.propertyA, ns.ex.end],
    [ns.ex.end, ns.ex.propertyB, ns.ex.end]
  ])
  const expectedQuads = [
    new Path({ dataset, term: edges[0].startTerm }),
    new Path({ edges: [edges[0]] })
  ]
  return { ...others, dataset, edges, expectedQuads }
}
single.traverseZeroOrMoreSelfRef2 = () => {
  const { dataset, edges, ...others } = createPathDataset([
    [ns.ex.start, ns.ex.propertyA, ns.ex.end1],
    [ns.ex.end1, ns.ex.propertyB, ns.ex.end2],
    [ns.ex.end2, ns.ex.propertyB, ns.ex.start]
  ])
  const expectedQuads = [
    new Path({ dataset, term: edges[0].startTerm }),
    new Path({ edges: [edges[0]] }),
    new Path({ edges: [edges[0], edges[1]] })
  ]
  return { ...others, dataset, edges, expectedQuads }
}
single.traverseZeroOrOne = () => {
  const { dataset, edges, ...others } = createPathDataset([
    [ns.ex.start, ns.ex.propertyA, ns.ex.end1],
    [ns.ex.start, ns.ex.propertyB, ns.ex.end2],
    [ns.ex.start, ns.ex.propertyC, ns.ex.deadEnd]
  ])
  const expectedQuads = [
    new Path({ dataset, term: edges[0].startTerm }),
    new Path({ edges: [edges[0]] }),
    new Path({ edges: [edges[1]] })
  ]
  return { ...others, dataset, edges, expectedQuads }
}
single.trim = () => {
  const { dataset, quads, ...others } = createPathDataset(triples.path)
  const ptr = new Path({
    edges: [
      new Edge({ dataset, quad: quads[0], start: 'subject', end: 'object' }),
      new Edge({ dataset, quad: quads[1], start: 'subject', end: 'object' })
    ]
  })
  const expectedPtr = new Path({ dataset, graph: ptr.edges[1].graph, term: ptr.term })
  return { ...others, dataset, expectedPtr, ptr, quads }
}
single.constructorEdges = single.out
single.constructorEdgesTerm = single.out
single.constructorEdgesGraph = single.outGraph
single.executeAddList = single.addList
single.executeAddOut = single.addOut
single.executeStartEnd = single.in
single.executeObjects = single.out
single.executePredicates = single.out
single.executeQuantifier = single.traverseOneOrMore
single.executeSubject = single.in
single.quadsEdges = single.nodes
single.startTerm = single.out
single.traverseOne = single.out
single.traverseOnePredicate = single.in
single.value = single.out
export default single

================
File: test/support/factory.js
================
import DataModelFactory from '@rdfjs/data-model/Factory.js'
import DatasetFactory from '@rdfjs/dataset/Factory.js'
import Environment from '@rdfjs/environment'
import TermSetFactory from '@rdfjs/term-set/Factory.js'
const env = new Environment([
  DataModelFactory,
  DatasetFactory,
  TermSetFactory
])
export default env

================
File: test/support/namespaces.js
================
import namespace from '@rdfjs/namespace'
const ex = namespace('http://example.org/')
const exCom = namespace('http://example.com/')
const other = namespace('http://other.example.org/')
const rdf = namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
const schema = namespace('http://schema.org/')
const xsd = namespace('http://www.w3.org/2001/XMLSchema#')
export {
  ex,
  exCom,
  other,
  rdf,
  schema,
  xsd
}

================
File: test/support/toJSON.js
================
import { deepStrictEqual } from 'assert'
import Edge from '../../Edge.js'
import Path from '../../Path.js'
import PathList from '../../PathList.js'
function arrayToJSON (array, { blankNodeIds }) {
  if (!Array.isArray(array)) {
    return null
  }
  return array.map(obj => toJSON(obj, { blankNodeIds }))
}
function edgeToJSON (step, { blankNodeIds }) {
  if (!(step instanceof Edge)) {
    return null
  }
  return {
    quad: quadToJSON(step.quad, { blankNodeIds }),
    start: step.start,
    end: step.end
  }
}
function listToJSON (list, { blankNodeIds }) {
  if (!(list instanceof PathList)) {
    return null
  }
  return {
    ptrs: list.ptrs.map(ptr => toJSON(ptr, { blankNodeIds }))
  }
}
function pathToJSON (path, { blankNodeIds }) {
  if (!(path instanceof Path)) {
    return null
  }
  const json = {
    edges: path.edges.map(step => edgeToJSON(step, { blankNodeIds }))
  }
  if (path._graph) {
    json.graph = path._graph.value
  }
  if (path._term) {
    json.startTerm = termToJSON(path._term, { blankNodeIds })
  }
  return json
}
function quadToJSON (quad, { blankNodeIds }) {
  if (quad.termType !== 'Quad') {
    return null
  }
  return {
    subject: termToJSON(quad.subject, { blankNodeIds }),
    predicate: termToJSON(quad.predicate, { blankNodeIds }),
    object: termToJSON(quad.object, { blankNodeIds }),
    graph: termToJSON(quad.graph, { blankNodeIds })
  }
}
function termToJSON (term, { blankNodeIds }) {
  if (!term.termType) {
    return null
  }
  const json = {
    termType: term.termType,
    value: term.value
  }
  if (term.termType === 'BlankNode') {
    if (!blankNodeIds.has(term.value)) {
      blankNodeIds.set(term.value, `b${blankNodeIds.size + 1}`)
    }
    json.value = blankNodeIds.get(term.value)
  }
  if (term.datatype) {
    json.datatype = termToJSON(term.datatype, { blankNodeIds })
  }
  if (term.language) {
    json.language = term.language
  }
  return json
}
function toJSON (obj, { blankNodeIds = new Map() } = {}) {
  return arrayToJSON(obj, { blankNodeIds }) ||
    edgeToJSON(obj, { blankNodeIds }) ||
    listToJSON(obj, { blankNodeIds }) ||
    pathToJSON(obj, { blankNodeIds })
}
function grapoiEqual (actual, expected) {
  deepStrictEqual(toJSON(actual), toJSON(expected))
}
export default toJSON
export {
  grapoiEqual
}

================
File: test/toPath.test.js
================
import { strictEqual, throws } from 'assert'
import { describe, it } from 'mocha'
import toPath from '../lib/toPath.js'
import Path from '../Path.js'
import factory from './support/factory.js'
import * as ns from './support/namespaces.js'
import { grapoiEqual } from './support/toJSON.js'
describe('toPath', () => {
  it('should be a function', () => {
    strictEqual(typeof toPath, 'function')
  })
  it('should return null if null is given', () => {
    strictEqual(toPath(null, {}), null)
  })
  it('should return undefined if undefined is given', () => {
    strictEqual(toPath(undefined, {}), undefined)
  })
  it('should create a Path with a Literal term if a string is given', () => {
    const dataset = factory.dataset()
    const ptr = new Path({ dataset, factory, term: factory.literal('test') })
    const result = toPath('test', { dataset, factory })
    grapoiEqual(result, ptr)
  })
  it('should create a Path with a NamedNode term if a URL is given', () => {
    const dataset = factory.dataset()
    const ptr = new Path({ dataset, factory, term: ns.ex.start })
    const result = toPath(new URL(ns.ex.start.value), { dataset, factory })
    grapoiEqual(result, ptr)
  })
  it('should wrap the given Term into a Path object', () => {
    const dataset = factory.dataset()
    const term = ns.ex.start
    const ptr = new Path({ dataset, factory, term })
    const result = toPath(term, { dataset, factory })
    grapoiEqual(result, ptr)
  })
  it('should forward the given Path object', () => {
    const dataset = factory.dataset()
    const ptr = new Path({ dataset, factory, term: ns.ex.start })
    const result = toPath(ptr, { dataset, factory })
    strictEqual(result, ptr)
  })
  it('should wrap the given ptr into a Path object', () => {
    const dataset = factory.dataset()
    const ptr = new Path({ dataset, factory, term: ns.ex.start })
    const result = toPath({ dataset, term: ptr.term }, { dataset, factory })
    grapoiEqual(result, ptr)
  })
  it('should handle any ptrs', () => {
    const dataset = factory.dataset()
    const ptr = new Path({ dataset, factory, term: null })
    const result = toPath({ dataset, term: ptr.term }, { dataset, factory })
    grapoiEqual(result, ptr)
  })
  it('should throw an error if the object can\'t be converted to a Path', () => {
    throws(() => {
      toPath(/.*/)
    })
  })
})

================
File: test/toPathArray.test.js
================
import { strictEqual, throws } from 'assert'
import { describe, it } from 'mocha'
import toPathArray from '../lib/toPathArray.js'
import Path from '../Path.js'
import factory from './support/factory.js'
import * as ns from './support/namespaces.js'
import { grapoiEqual } from './support/toJSON.js'
describe('toPathArray', () => {
  it('should be a function', () => {
    strictEqual(typeof toPathArray, 'function')
  })
  it('should wrap a single Path into an array', () => {
    const dataset = factory.dataset()
    const ptr = new Path({ dataset, factory, term: ns.ex.start })
    const result = toPathArray(ptr, {})
    grapoiEqual(result, [ptr])
  })
  it('should wrap a single Term into an Path array', () => {
    const dataset = factory.dataset()
    const ptr = new Path({ dataset, factory, term: ns.ex.start })
    const result = toPathArray(ptr.term, { dataset, factory })
    grapoiEqual(result, [ptr])
  })
  it('should forward Paths into a new Path array', () => {
    const dataset = factory.dataset()
    const ptr1 = new Path({ dataset, factory, term: ns.ex.start1 })
    const ptr2 = new Path({ dataset, factory, term: ns.ex.start2 })
    const result = toPathArray([ptr1, ptr2], { dataset, factory })
    strictEqual(Array.isArray(result), true)
    strictEqual(result.length, 2)
    strictEqual(result[0], ptr1)
    strictEqual(result[1], ptr2)
  })
  it('should handle Sets', () => {
    const dataset = factory.dataset()
    const ptr1 = new Path({ dataset, factory, term: ns.ex.start1 })
    const ptr2 = new Path({ dataset, factory, term: ns.ex.start2 })
    const result = toPathArray(new Set([ptr1, ptr2]), { dataset, factory })
    grapoiEqual(result, [ptr1, ptr2])
  })
  it('should wrap terms given in an array into a Path array', () => {
    const dataset = factory.dataset()
    const ptr1 = new Path({ dataset, factory, term: ns.ex.start1 })
    const ptr2 = new Path({ dataset, factory, term: ns.ex.start2 })
    const result = toPathArray([ptr1.term, ptr2.term], { dataset, factory })
    grapoiEqual(result, [ptr1, ptr2])
  })
  it('should wrap terms and graphs given in an array into a Path array', () => {
    const dataset = factory.dataset()
    const ptr1 = new Path({ dataset, factory, term: ns.ex.start1, graph: ns.ex.graph1 })
    const ptr2 = new Path({ dataset, factory, term: ns.ex.start1, graph: ns.ex.graph2 })
    const ptr3 = new Path({ dataset, factory, term: ns.ex.start2, graph: ns.ex.graph1 })
    const ptr4 = new Path({ dataset, factory, term: ns.ex.start2, graph: ns.ex.graph2 })
    const result = toPathArray([ns.ex.start1, ns.ex.start2], { dataset, factory, graph: [ns.ex.graph1, ns.ex.graph2] })
    grapoiEqual(result, [ptr1, ptr2, ptr3, ptr4])
  })
  it('should throw an error if the value can\'t be converted', () => {
    throws(() => {
      toPathArray(/.*/, {})
    })
  })
  it('should throw an error if a value can\'t be converted', () => {
    throws(() => {
      toPathArray([/.*/], {})
    })
  })
})

================
File: test/toTerm.test.js
================
import { strictEqual, throws } from 'assert'
import { describe, it } from 'mocha'
import toTerm from '../lib/toTerm.js'
import factory from './support/factory.js'
import * as ns from './support/namespaces.js'
describe('toTerm', () => {
  it('should be a function', () => {
    strictEqual(typeof toTerm, 'function')
  })
  it('should return null if null is given', () => {
    strictEqual(toTerm(null, { factory }), null)
  })
  it('should return undefined if undefined is given', () => {
    strictEqual(toTerm(undefined, { factory }), undefined)
  })
  it('should create a Literal if a string is given', () => {
    strictEqual(factory.literal('test').equals(toTerm('test', { factory })), true)
  })
  it('should create a NamedNode if a URL is given', () => {
    strictEqual(ns.ex.start.equals(toTerm(new URL(ns.ex.start.value), { factory })), true)
  })
  it('should return the given term', () => {
    const term = ns.ex.start
    strictEqual(toTerm(term, { factory }), term)
  })
  it('should return term of a ptr object', () => {
    const ptr = { term: ns.ex.start }
    strictEqual(toTerm(ptr, { factory }), ptr.term)
  })
  it('should return null if the term of a ptr object is null', () => {
    strictEqual(toTerm({ term: null }, { factory }), null)
  })
  it('should throw an error if the object can\'t be converted to a term', () => {
    throws(() => {
      toTerm(/.*/, { factory })
    })
  })
})

================
File: test/toTermArray.test.js
================
import { deepStrictEqual, strictEqual, throws } from 'assert'
import { describe, it } from 'mocha'
import toTermArray from '../lib/toTermArray.js'
import factory from './support/factory.js'
import * as ns from './support/namespaces.js'
describe('toTermArray', () => {
  it('should be a function', () => {
    strictEqual(typeof toTermArray, 'function')
  })
  it('should wrap the given Term into an Array', () => {
    const term = ns.ex.start
    const result = toTermArray(term, { factory })
    deepStrictEqual(result, [term])
  })
  it('should use the Term of the given ptr and wrap it into an Array', () => {
    const ptr = { term: ns.ex.start }
    const result = toTermArray(ptr, { factory })
    deepStrictEqual(result, [ptr.term])
  })
  it('should convert the given string to a Literal and wrap it into an Array', () => {
    const term = factory.literal('test')
    const result = toTermArray(term.value, { factory })
    deepStrictEqual(result, [term])
  })
  it('should forward the Terms given in an array', () => {
    const terms = [ns.ex.start1, ns.ex.start2]
    const result = toTermArray(terms, { factory })
    deepStrictEqual(result, terms)
  })
  it('should forward the Terms given in a set', () => {
    const terms = [ns.ex.start1, ns.ex.start2]
    const result = toTermArray(new Set(terms), { factory })
    deepStrictEqual(result, terms)
  })
  it('should use the Terms of the ptrs given as an array', () => {
    const ptrs = [{ term: ns.ex.start1 }, { term: ns.ex.start2 }]
    const result = toTermArray(ptrs, { factory })
    deepStrictEqual(result, [ptrs[0].term, ptrs[1].term])
  })
  it('should throw an error if the value can\'t be converted', () => {
    throws(() => {
      toTermArray(/.*/, { factory })
    })
  })
  it('should throw an error if a value can\'t be converted', () => {
    throws(() => {
      toTermArray([/.*/], { factory })
    })
  })
})
