================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-09-11T16:33:51.379Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.
- Code comments have been removed.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

Additional User-Provided Header:
--------------------------------
Transmissions repo

================================================================
Repository Files
================================================================

================
File: .github/workflows/test.yaml
================
name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-20.04
    strategy:
      matrix:
        node:
          - '16'
          - '18'
          - '20'
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node }}
      - run: npm install
      - run: npm test
      - uses: codecov/codecov-action@v3

================
File: CONTRIBUTING.md
================
# Contributing to a project of the RDF-Ext organization

We'd love for you to contribute to our source code and to make RDF-Ext even better than it is today!
Here are the guidelines we'd like you to follow:

## Discussions

The [discussions project](https://github.com/rdf-ext/discussions/issues) is the right place to talk about general RDF-Ext topics.
If you are not sure to which project your topic belongs, just open an issue in that project.

## Styleguide

All projects managed in the RDF-Ext organization use the [standard code style](http://standardjs.com/).
Standard is also configured in the `test` script in every `package.json` file.
So you can use `npm test` to check the style.

## Pull Requests

All developers, also members of the organization, must use forks and pull requests to submit contributions.

## Branches

Gitflow is used to manage branches and versions.
The workflow is described [here](http://nvie.com/posts/a-successful-git-branching-model/) and [here](https://de.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow)

## Tests

All contributions should be covered by a mocha test.

================
File: DataFactory.js
================
import fromTerm from '@rdfjs/data-model/lib/fromTerm.js'
import BlankNode from './lib/BlankNode.js'
import DefaultGraph from './lib/DefaultGraph.js'
import Literal from './lib/Literal.js'
import NamedNode from './lib/NamedNode.js'
import Quad from './lib/Quad.js'
import Variable from './lib/Variable.js'
const langStringDatatype = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')
const stringDatatype = new NamedNode('http://www.w3.org/2001/XMLSchema#string')
class DataFactory {
  init () {
    this._data = {
      blankNodeCounter: 0,
      defaultGraph: new DefaultGraph()
    }
  }
  namedNode (value) {
    if (typeof value !== 'string') {
      value = value.toString()
    }
    return new NamedNode(value)
  }
  blankNode (value) {
    value = value || ('b' + (++this._data.blankNodeCounter))
    return new BlankNode(value)
  }
  literal (value, languageOrDatatype) {
    if (typeof languageOrDatatype === 'string') {
      return new Literal(value, languageOrDatatype, langStringDatatype)
    } else {
      return new Literal(value, '', languageOrDatatype || stringDatatype)
    }
  }
  variable (value) {
    return new Variable(value)
  }
  defaultGraph () {
    return this._data.defaultGraph
  }
  quad (subject, predicate, object, graph = this.defaultGraph()) {
    return new Quad(subject, predicate, object, graph)
  }
  fromTerm (original) {
    return fromTerm(this, original)
  }
  fromQuad (original) {
    return fromTerm(this, original)
  }
}
DataFactory.exports = [
  'namedNode',
  'blankNode',
  'literal',
  'variable',
  'defaultGraph',
  'quad',
  'fromTerm',
  'fromQuad'
]
export default DataFactory

================
File: DatasetFactory.js
================
import Dataset from './lib/Dataset.js'
class DatasetFactory {
  dataset (quads, graph) {
    const dataset = new Dataset()
    if (quads) {
      if (graph) {
        for (const quad of quads) {
          dataset.add(this.quad(quad.subject, quad.predicate, quad.object, graph))
        }
      } else {
        dataset.addAll(quads)
      }
    }
    return dataset
  }
}
DatasetFactory.exports = ['dataset']
export default DatasetFactory

================
File: FetchFactory.js
================
import FetchFactoryBase from '@rdfjs/fetch-lite/Factory.js'
import fetch from './lib/fetch.js'
class FetchFactory extends FetchFactoryBase {
  init () {
    super.init()
    this.fetch.config('fetch', fetch)
  }
}
export default FetchFactory

================
File: FormatsFactory.js
================
import formats from '@rdfjs/formats'
import FormatsFactoryBase from '@rdfjs/formats/Factory.js'
class FormatsFactory extends FormatsFactoryBase {
  init () {
    super.init()
    this.formats.import(formats)
  }
}
export default FormatsFactory

================
File: LICENSE.md
================
# License
The MIT License (MIT)
Copyright © 2012–2015 Thomas Bergwinkl

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

================
File: README.md
================
# rdf-ext

[![build status](https://img.shields.io/github/actions/workflow/status/rdf-ext/rdf-ext/test.yaml?branch=master)](https://github.com/rdf-ext/rdf-ext/actions/workflows/test.yaml)
[![npm version](https://img.shields.io/npm/v/rdf-ext.svg)](https://www.npmjs.com/package/rdf-ext)

RDF-Ext is a JavaScript library that extends the [RDF/JS](#rdf-js) specs to handle RDF data in a developer-friendly way.

## Install

```bash
npm install --save rdf-ext
```

## Usage

Just import the default export from the package:

```javascript
import rdf from 'rdf-ext'

const term = rdf.namedNode('http://example.org/')
```

The exported object is an instance of [@rdfjs/environment](https://github.com/rdfjs-base/environment).
The following factories are included in the environment:

- [DataFactory](https://github.com/rdfjs-base/data-model)
- [DatasetFactory](https://github.com/rdfjs-base/dataset)
- [FetchFactory](https://github.com/rdfjs-base/fetch-lite)
- [FormatsFactory](https://github.com/rdfjs-base/formats-common)
- [GrapoiFactory](https://github.com/rdf-ext/grapoi)
- [NamespaceFactory](https://github.com/rdfjs-base/namespace)
- [PrefixMapFactory](https://github.com/rdfjs-base/prefix-map)
- [TermMapFactory](https://github.com/rdfjs-base/term-map/)
- [TermSetFactory](https://github.com/rdfjs-base/term-set)
- [TraverserFactory](https://github.com/rdfjs-base/traverser)

### Experimental features

The package contains experimental features which may break or be removed without being covered in the semantic versioning:

- [ScoreFactory](https://github.com/rdfjs-base/score/#factory)

## Documentation & examples

For more details, please check [rdf-ext.org](https://rdf-ext.org/)

================
File: index.js
================
import Environment from '@rdfjs/environment/Environment.js'
import IoFactory from '@rdfjs/io/Factory.js'
import NamespaceFactory from '@rdfjs/namespace/Factory.js'
import PrefixMapFactory from '@rdfjs/prefix-map/Factory.js'
import ScoreFactory from '@rdfjs/score/Factory.js'
import TermMapFactory from '@rdfjs/term-map/Factory.js'
import TermSetFactory from '@rdfjs/term-set/Factory.js'
import TraverserFactory from '@rdfjs/traverser/Factory.js'
import GrapoiFactory from 'grapoi/Factory.js'
import DataFactory from './DataFactory.js'
import DatasetFactory from './DatasetFactory.js'
import FetchFactory from './FetchFactory.js'
import FormatsFactory from './FormatsFactory.js'
const defaultEnv = new Environment([
  DataFactory,
  DatasetFactory,
  FetchFactory,
  FormatsFactory,
  GrapoiFactory,
  IoFactory,
  NamespaceFactory,
  PrefixMapFactory,
  ScoreFactory,
  TermMapFactory,
  TermSetFactory,
  TraverserFactory
], { bind: true })
export default defaultEnv
export {
  DataFactory,
  DatasetFactory,
  Environment,
  FetchFactory,
  FormatsFactory,
  GrapoiFactory,
  NamespaceFactory,
  PrefixMapFactory,
  ScoreFactory,
  TermMapFactory,
  TermSetFactory,
  TraverserFactory
}

================
File: lib/BlankNode.js
================
import BlankNodeBase from '@rdfjs/data-model/lib/BlankNode.js'
import toNT from '@rdfjs/to-ntriples'
class BlankNode extends BlankNodeBase {
  toCanonical () {
    return toNT(this)
  }
  toString () {
    return this.toCanonical()
  }
}
export default BlankNode

================
File: lib/Dataset.js
================
import Dataset from '@rdfjs/dataset/DatasetCore.js'
import normalize from '@rdfjs/normalize'
import toNT from '@rdfjs/to-ntriples'
import { finished, Readable } from 'readable-stream'
function createDataset (obj, quads) {
  return new obj.constructor(quads)
}
class DatasetExt extends Dataset {
  addAll (quads) {
    for (const quad of quads) {
      this.add(quad)
    }
    return this
  }
  clone () {
    return createDataset(this, this)
  }
  deleteMatches (subject, predicate, object, graph) {
    for (const quad of this.match(subject, predicate, object, graph)) {
      this.delete(quad)
    }
    return this
  }
  difference (other) {
    return this.filter(quad => !other.has(quad))
  }
  equals (other) {
    return this.toCanonical() === other.toCanonical()
  }
  every (callback) {
    return Array.from(this).every(quad => callback(quad, this))
  }
  filter (callback) {
    return createDataset(this, Array.from(this).filter(quad => callback(quad, this)))
  }
  forEach (callback) {
    Array.from(this).forEach(quad => callback(quad, this))
  }
  import (stream) {
    stream.on('data', quad => this.add(quad))
    return new Promise((resolve, reject) => {
      finished(stream, err => {
        if (err) {
          reject(err)
        } else {
          resolve(this)
        }
      })
    })
  }
  intersection (other) {
    return this.filter(quad => other.has(quad))
  }
  map (callback) {
    return createDataset(this, Array.from(this).map(quad => callback(quad, this)))
  }
  merge (other) {
    return (this.clone()).addAll(other)
  }
  reduce (callback, initialValue) {
    return Array.from(this).reduce((value, quad, index) => callback(value, quad, index, this), initialValue)
  }
  some (callback) {
    return Array.from(this).some(quad => callback(quad, this))
  }
  toCanonical () {
    return normalize(this)
  }
  toStream () {
    return Readable.from(this)
  }
  toString () {
    return toNT(this)
  }
}
export default DatasetExt

================
File: lib/DefaultGraph.js
================
import DefaultGraphBase from '@rdfjs/data-model/lib/DefaultGraph.js'
import toNT from '@rdfjs/to-ntriples'
class DefaultGraph extends DefaultGraphBase {
  toCanonical () {
    return toNT(this)
  }
  toString () {
    return this.toCanonical()
  }
}
export default DefaultGraph

================
File: lib/Literal.js
================
import LiteralBase from '@rdfjs/data-model/lib/Literal.js'
import toNT from '@rdfjs/to-ntriples'
class Literal extends LiteralBase {
  toCanonical () {
    return toNT(this)
  }
  toString () {
    return this.value
  }
}
export default Literal

================
File: lib/NamedNode.js
================
import NamedNodeBase from '@rdfjs/data-model/lib/NamedNode.js'
import toNT from '@rdfjs/to-ntriples'
class NamedNode extends NamedNodeBase {
  toCanonical () {
    return toNT(this)
  }
  toString () {
    return this.value
  }
  toURL () {
    return new URL(this.value)
  }
}
export default NamedNode

================
File: lib/Quad.js
================
import QuadBase from '@rdfjs/data-model/lib/Quad.js'
import toNT from '@rdfjs/to-ntriples'
class Quad extends QuadBase {
  toCanonical () {
    return toNT(this)
  }
  toString () {
    return this.toCanonical()
  }
}
export default Quad

================
File: lib/Variable.js
================
import VariableBase from '@rdfjs/data-model/lib/Variable.js'
import toNT from '@rdfjs/to-ntriples'
class Variable extends VariableBase {
  toCanonical () {
    return toNT(this)
  }
  toString () {
    return this.toCanonical()
  }
}
export default Variable

================
File: lib/fetch.browser.js
================
import httpFetch from 'nodeify-fetch'
export default httpFetch

================
File: lib/fetch.js
================
import rdfMediaTypes from '@rdfjs/io/mediaTypes.js'
import fileFetchFactory from 'file-fetch/factory.js'
import httpFetch from 'nodeify-fetch'
import protoFetch from 'proto-fetch'
const fileFetch = fileFetchFactory({
  contentType: ext => rdfMediaTypes.get(ext.slice(1))
})
const fetch = protoFetch({
  [null]: fileFetch,
  file: fileFetch,
  http: httpFetch,
  https: httpFetch
})
export default fetch

================
File: package.json
================
{
  "name": "rdf-ext",
  "version": "2.5.1",
  "description": "RDF-Ext is a developer-friendly extension for RDF/JS",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "stricter-standard && c8 --reporter=lcov --reporter=text-summary mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/rdf-ext/rdf-ext.git"
  },
  "keywords": [
    "rdf",
    "rdfjs",
    "rdf-ext"
  ],
  "author": "Thomas Bergwinkl <bergi@axolotlfarm.org> (https://www.bergnet.org/people/bergi/card#me)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/rdf-ext/rdf-ext/issues"
  },
  "homepage": "https://github.com/rdf-ext/rdf-ext",
  "dependencies": {
    "@rdfjs/data-model": "^2.0.1",
    "@rdfjs/dataset": "^2.0.1",
    "@rdfjs/environment": "^1.0.0",
    "@rdfjs/fetch-lite": "^3.2.1",
    "@rdfjs/formats": "^4.0.0",
    "@rdfjs/io": "^1.0.0",
    "@rdfjs/namespace": "^2.0.0",
    "@rdfjs/normalize": "^2.0.0",
    "@rdfjs/prefix-map": "^0.1.1",
    "@rdfjs/score": "^0.1.1",
    "@rdfjs/term-map": "^2.0.0",
    "@rdfjs/term-set": "^2.0.1",
    "@rdfjs/to-ntriples": "^2.0.0",
    "@rdfjs/traverser": "^0.1.1",
    "file-fetch": "^2.0.0",
    "grapoi": "^1.0.2",
    "nodeify-fetch": "^3.1.0",
    "proto-fetch": "^2.0.0",
    "readable-stream": "^4.3.0"
  },
  "devDependencies": {
    "c8": "^7.12.0",
    "mocha": "^10.2.0",
    "stream-chunks": "^1.0.0",
    "stricter-standard": "^0.2.0"
  },
  "browser": {
    "./lib/fetch.js": "./lib/fetch.browser.js"
  }
}

================
File: test/BlankNode.test.js
================
import { strictEqual } from 'assert'
import { describe, it } from 'mocha'
import BlankNode from '../lib/BlankNode.js'
describe('BlankNode', () => {
  describe('.toCanonical', () => {
    it('should be a method', () => {
      const term = new BlankNode()
      strictEqual(typeof term.toCanonical, 'function')
    })
    it('should return the identifier prefixed with "_:"', () => {
      const id = 'b1'
      const term = new BlankNode(id)
      strictEqual(term.toCanonical(), '_:' + id)
    })
  })
  describe('.toString', () => {
    it('should be a method', () => {
      const term = new BlankNode()
      strictEqual(typeof term.toString, 'function')
    })
    it('should return the identifier prefixed with "_:"', () => {
      const id = 'b1'
      const term = new BlankNode(id)
      strictEqual(term.toString(), '_:' + id)
    })
  })
})

================
File: test/DataFactory.test.js
================
import { strictEqual } from 'assert'
import testSuite from '@rdfjs/data-model/test/index.js'
import mocha from 'mocha'
import DataFactory from '../DataFactory.js'
import { Environment } from '../index.js'
const env = new Environment([DataFactory])
mocha.describe('DataFactory', () => {
  mocha.describe('test suite', () => {
    testSuite({ factory: env, mocha })
  })
  mocha.describe('namedNode', () => {
    mocha.it('should accept URL objects and convert them to strings', () => {
      const iri = 'http://example.org/path?query=value'
      const namedNode = env.namedNode(new URL(iri))
      strictEqual(namedNode.value, iri)
    })
  })
})

================
File: test/Dataset.test.js
================
import { deepStrictEqual, rejects, strictEqual } from 'assert'
import { describe, it } from 'mocha'
import { Readable } from 'readable-stream'
import chunks from 'stream-chunks/chunks.js'
import rdf from '../index.js'
import Dataset from '../lib/Dataset.js'
import example from './support/exampleData.js'
import spogFilter from './support/spogFilter.js'
describe('Dataset', () => {
  describe('.addAll', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.addAll, 'function')
    })
    it('should import all quads from the given iterable', () => {
      const dataset1 = new Dataset([example.quad1])
      const dataset2 = new Dataset([example.quad2])
      const dataset3 = dataset1.addAll(dataset2)
      strictEqual(dataset1.size, 2)
      strictEqual(dataset2.size, 1)
      strictEqual(dataset3.size, 2)
    })
  })
  describe('.clone', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.clone, 'function')
    })
    it('should create a new dataset instance that contains all quads of the original', () => {
      const dataset = new Dataset()
      dataset.add(example.quad)
      const clone = dataset.clone()
      strictEqual(dataset === clone, false)
      strictEqual(clone.has(example.quad), true)
    })
  })
  describe('.difference', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.difference, 'function')
    })
    it('should return a dataset with quads not included in the other dataset', () => {
      const dataset1 = new Dataset([example.quad1, example.quad2])
      const dataset2 = new Dataset([example.quad2, example.quad3])
      const difference = dataset1.difference(dataset2)
      strictEqual(difference.size, 1)
      strictEqual(difference.has(example.quad1), true)
    })
  })
  describe('.every', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.every, 'function')
    })
    it('should return true if every quad pass the filter test', () => {
      const dataset = new Dataset([example.quad1, example.quad2])
      strictEqual(dataset.every(spogFilter(example.subject, null, null)), true)
      strictEqual(dataset.every(spogFilter(null, null, example.object3)), false)
    })
  })
  describe('.filter', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.filter, 'function')
    })
    it('.filter should return a new dataset that contains all quads that pass the filter test', () => {
      const dataset = new Dataset([example.quad1, example.quad2])
      strictEqual(dataset.filter(spogFilter(example.subject, null, null)).size, 2)
      strictEqual(dataset.filter(spogFilter(null, null, example.object1)).size, 1)
      strictEqual(dataset.filter(spogFilter(null, null, example.object3)).size, 0)
    })
  })
  describe('.forEach', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.forEach, 'function')
    })
    it('should call the callback function for every quad', () => {
      const objects = []
      const dataset = new Dataset([example.quad1, example.quad2])
      dataset.forEach(quad => objects.push(quad.object.value))
      deepStrictEqual(objects, ['1', '2'])
    })
  })
  describe('.import', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.import, 'function')
    })
    it('.import should import quads from stream', async () => {
      const stream = Readable.from([example.quad1, example.quad2])
      const dataset = new Dataset()
      await dataset.import(stream)
      strictEqual(dataset.has(example.quad1), true)
      strictEqual(dataset.has(example.quad2), true)
    })
    it('.import should forward stream errors', async () => {
      const stream = new Readable({
        read: () => {
          stream.destroy(new Error('example'))
        }
      })
      const dataset = new Dataset()
      await rejects(async () => {
        await dataset.import(stream)
      })
    })
  })
  describe('.intersection', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.intersection, 'function')
    })
    it('should return a dataset with quads included also in the other dataset', () => {
      const dataset1 = new Dataset([example.quad1, example.quad2])
      const dataset2 = new Dataset([example.quad2, example.quad3])
      const intersection = dataset1.intersection(dataset2)
      strictEqual(intersection.size, 1)
      strictEqual(intersection.has(example.quad2), true)
    })
  })
  describe('.map', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.map, 'function')
    })
    it('should call the callback function for every quad and return a Dataset that contains the new quads', () => {
      const mappedQuad = rdf.quad(example.subject, example.predicate, rdf.literal('11'))
      const dataset = new Dataset([example.quad1])
      const mappedDataset = dataset.map(quad => {
        return rdf.quad(quad.subject, quad.predicate, rdf.literal(quad.object.value + '1'))
      })
      strictEqual(mappedDataset.size, 1)
      strictEqual(mappedDataset.has(mappedQuad), true)
    })
  })
  describe('.merge', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.merge, 'function')
    })
    it('should return a new dataset that contains all quads from the dataset and the given dataset', () => {
      const dataset1 = new Dataset([example.quad1])
      const dataset2 = new Dataset([example.quad2])
      const dataset3 = dataset1.merge(dataset2)
      strictEqual(dataset1.size, 1)
      strictEqual(dataset2.size, 1)
      strictEqual(dataset3.size, 2)
    })
  })
  describe('.deleteMatches', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.deleteMatches, 'function')
    })
    it('should remove all quads that pass the subject match pattern and return the dataset itself', () => {
      const quad1 = rdf.quad(example.subject1, example.predicate, example.object, example.graph)
      const quad2 = rdf.quad(example.subject2, example.predicate, example.object, example.graph)
      const dataset = new Dataset([quad1, quad2])
      strictEqual(dataset.deleteMatches(example.subject3, null, null, null).size, 2)
      strictEqual(dataset.deleteMatches(example.subject2, null, null, null).size, 1)
      strictEqual(dataset.deleteMatches(example.subject1, null, null, null).size, 0)
    })
    it('should remove all quads that pass the predicate match pattern and return the dataset itself', () => {
      const quad1 = rdf.quad(example.subject, example.predicate1, example.object, example.graph)
      const quad2 = rdf.quad(example.subject, example.predicate2, example.object, example.graph)
      const dataset = new Dataset([quad1, quad2])
      strictEqual(dataset.deleteMatches(null, example.predicate3, null, null).size, 2)
      strictEqual(dataset.deleteMatches(null, example.predicate2, null, null).size, 1)
      strictEqual(dataset.deleteMatches(null, example.predicate1, null, null).size, 0)
    })
    it('should remove all quads that pass the object match pattern and return the dataset itself', () => {
      const quad1 = rdf.quad(example.subject, example.predicate, example.object1, example.graph)
      const quad2 = rdf.quad(example.subject, example.predicate, example.object2, example.graph)
      const dataset = new Dataset([quad1, quad2])
      strictEqual(dataset.deleteMatches(null, null, example.object3, null).size, 2)
      strictEqual(dataset.deleteMatches(null, null, example.object2, null).size, 1)
      strictEqual(dataset.deleteMatches(null, null, example.object1, null).size, 0)
    })
    it('should remove all quads that pass the graph match pattern and return the dataset itself', () => {
      const quad1 = rdf.quad(example.subject, example.predicate, example.object, example.graph1)
      const quad2 = rdf.quad(example.subject, example.predicate, example.object, example.graph2)
      const dataset = new Dataset([quad1, quad2])
      strictEqual(dataset.deleteMatches(null, null, null, example.graph3).size, 2)
      strictEqual(dataset.deleteMatches(null, null, null, example.graph2).size, 1)
      strictEqual(dataset.deleteMatches(null, null, null, example.graph1).size, 0)
    })
  })
  describe('.reduce', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.reduce, 'function')
    })
    it('should call the callback function with the result of the previous value as first argument', () => {
      const dataset = new Dataset([example.quad1, example.quad2])
      const result = dataset.reduce((value, quad) => value + quad.object.value, '')
      strictEqual(result, '12')
    })
    it('should call the callback function for every quad with the quad as second argument', () => {
      const objects = []
      const dataset = new Dataset([example.quad1, example.quad2])
      dataset.reduce((accumulator, quad) => objects.push(quad.object.value))
      deepStrictEqual(objects, ['1', '2'])
    })
    it('should call the callback function with the index as third argument', () => {
      const dataset = new Dataset([example.quad1, example.quad2])
      const result = dataset.reduce((value, quad, index) => value + index, '')
      strictEqual(result, '01')
    })
    it('should call the callback function with the dataset as fourth argument', () => {
      const datasets = []
      const dataset = new Dataset([example.quad1, example.quad2])
      dataset.reduce((value, quad, index, dataset) => datasets.push(dataset))
      strictEqual(datasets.length, 2)
      strictEqual(datasets[0], dataset)
      strictEqual(datasets[1], dataset)
    })
    it('should use the initial value', () => {
      const objects = []
      const dataset = new Dataset([example.quad1, example.quad2])
      const result = dataset.reduce((value, quad) => value + objects.push(quad.object.value), '0')
      strictEqual(result, '012')
    })
  })
  describe('.some', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.some, 'function')
    })
    it('should return true if any quad passes the filter test', () => {
      const dataset = new Dataset([example.quad1, example.quad2])
      strictEqual(dataset.some(spogFilter(null, null, example.object2)), true)
      strictEqual(dataset.some(spogFilter(null, null, example.object3)), false)
    })
  })
  describe('.toStream', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.toStream, 'function')
    })
    it('should return a stream which emits all quads of the dataset', async () => {
      const dataset = new Dataset([example.quad1, example.quad2])
      const stream = dataset.toStream()
      const output = await chunks(stream)
      strictEqual(output.length, 2)
      strictEqual(dataset.has(output[0]), true)
      strictEqual(dataset.has(output[1]), true)
      strictEqual(output[0].equals(output[1]), false)
    })
  })
  describe('.equals', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.equals, 'function')
    })
    it('should compare the other graph for equality', () => {
      const quad1a = rdf.quad(example.subject, example.predicate, rdf.blankNode())
      const quad1b = rdf.quad(example.subject, example.predicate, rdf.blankNode())
      const dataset1a = rdf.dataset([quad1a])
      const dataset1b = rdf.dataset([quad1b])
      const dataset2 = rdf.dataset([example.quad2])
      strictEqual(dataset1a.equals(dataset1b), true)
      strictEqual(dataset1a.equals(dataset2), false)
    })
  })
  describe('.toCanonical', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.toCanonical, 'function')
    })
    it('should return the canonical representation', () => {
      const quad = rdf.quad(example.subject, example.predicate, rdf.blankNode())
      const quadNT = `${quad.subject.toCanonical()} ${quad.predicate.toCanonical()} _:c14n0 .\n`
      const dataset = rdf.dataset([quad])
      strictEqual(dataset.toCanonical(), quadNT, true)
    })
  })
  describe('.toString', () => {
    it('should be a method', () => {
      const dataset = new Dataset()
      strictEqual(typeof dataset.toString, 'function')
    })
    it('should return N-Quads', () => {
      const quad = rdf.quad(example.subject, example.predicate, example.object, example.graph)
      const quadNT = `${quad.toString()}\n`
      const dataset = rdf.dataset([quad])
      strictEqual(dataset.toString(), quadNT)
    })
  })
})

================
File: test/DatasetFactory.test.js
================
import { strictEqual } from 'assert'
import standard from '@rdfjs/dataset/test/index.js'
import mocha from 'mocha'
import rdf from '../index.js'
import DatasetExt from '../lib/Dataset.js'
import example from './support/exampleData.js'
const { describe, it } = mocha
describe('DatasetFactory', () => {
  describe('test suite', () => {
    standard({ factory: rdf, mocha })
  })
  describe('.dataset', () => {
    it('should be a function', () => {
      strictEqual(typeof rdf.dataset, 'function')
    })
    it('should return a DatasetExt instance', () => {
      strictEqual(rdf.dataset() instanceof DatasetExt, true)
    })
    it('should always return a DatasetExt instance', () => {
      strictEqual(rdf.dataset().clone() instanceof DatasetExt, true)
      strictEqual(rdf.dataset().merge(rdf.dataset()) instanceof DatasetExt, true)
      strictEqual(rdf.dataset().filter(() => true) instanceof DatasetExt, true)
    })
    it('should initialize the Dataset with the given quads', () => {
      const dataset = rdf.dataset([example.quad1, example.quad2])
      strictEqual(dataset.size, 2)
      strictEqual(dataset.match(null, null, example.object1).size, 1)
      strictEqual(dataset.match(null, null, example.object2).size, 1)
      strictEqual(dataset.match(null, null, null, example.graph).size, 2)
    })
    it('should replace the graph part of the quad if a second parameter is given', () => {
      const dataset = rdf.dataset([example.quad], example.graph1)
      strictEqual(dataset.size, 1)
      strictEqual([...dataset][0].graph.value, example.graph1.value)
    })
  })
})

================
File: test/DefaultGraph.test.js
================
import { strictEqual } from 'assert'
import { describe, it } from 'mocha'
import DefaultGraph from '../lib/DefaultGraph.js'
describe('DefaultGraph', () => {
  describe('.toCanonical', () => {
    it('should be a method', () => {
      const term = new DefaultGraph()
      strictEqual(typeof term.toCanonical, 'function')
    })
    it('should return an empty string', () => {
      const term = new DefaultGraph()
      strictEqual(term.toCanonical(), '')
    })
  })
  describe('.toString', () => {
    it('should be a method', () => {
      const term = new DefaultGraph()
      strictEqual(typeof term.toString, 'function')
    })
    it('should return an empty string', () => {
      const term = new DefaultGraph()
      strictEqual(term.toString(), '')
    })
  })
})

================
File: test/Literal.test.js
================
import { strictEqual } from 'assert'
import { describe, it } from 'mocha'
import Literal from '../lib/Literal.js'
import NamedNode from '../lib/NamedNode.js'
const langStringDatatype = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')
const stringDatatype = new NamedNode('http://www.w3.org/2001/XMLSchema#string')
describe('Literal', () => {
  describe('.toCanonical', () => {
    it('should be a method', () => {
      const term = new Literal()
      strictEqual(typeof term.toCanonical, 'function')
    })
    it('should return the string wrapped in double quotes', () => {
      const string = 'example'
      const term = new Literal(string, null, stringDatatype)
      strictEqual(term.toCanonical(), '"' + string + '"')
    })
    it('should support language literals', () => {
      const string = 'example'
      const language = 'en'
      const term = new Literal(string, language, langStringDatatype)
      strictEqual(term.toCanonical(), '"' + string + '"@' + language)
    })
    it('should support datatype literals', () => {
      const string = 'example'
      const datatype = new NamedNode('http://example.org/datatype')
      const term = new Literal(string, null, datatype)
      strictEqual(term.toCanonical(), '"' + string + '"^^<' + datatype.value + '>')
    })
    it('should escape special chars', () => {
      const quotationMarkTerm = new Literal('"', null, stringDatatype)
      const backslashTerm = new Literal('\\', null, stringDatatype)
      const lineFeedTerm = new Literal('\n', null, stringDatatype)
      const carriageReturnTerm = new Literal('\r', null, stringDatatype)
      strictEqual(quotationMarkTerm.toCanonical(), '"\\""')
      strictEqual(backslashTerm.toCanonical(), '"\\\\"')
      strictEqual(lineFeedTerm.toCanonical(), '"\\n"')
      strictEqual(carriageReturnTerm.toCanonical(), '"\\r"')
    })
  })
  describe('.toString', () => {
    it('should be a method', () => {
      const term = new Literal()
      strictEqual(typeof term.toString, 'function')
    })
    it('should return the string', () => {
      const string = 'example'
      const term = new Literal(string, null, stringDatatype)
      strictEqual(term.toString(), string)
    })
  })
})

================
File: test/NamedNode.test.js
================
import { strictEqual } from 'assert'
import { describe, it } from 'mocha'
import NamedNode from '../lib/NamedNode.js'
describe('NamedNode', () => {
  describe('.toCanonical', () => {
    it('should be a method', () => {
      const iri = 'http://example.org'
      const term = new NamedNode(iri)
      strictEqual(typeof term.toCanonical, 'function')
    })
    it('should return the IRI wrapped in angle brackets', () => {
      const iri = 'http://example.org'
      const term = new NamedNode(iri)
      strictEqual(term.toCanonical(), '<' + iri + '>')
    })
  })
  describe('.toString', () => {
    it('should be a method', () => {
      const iri = 'http://example.org'
      const term = new NamedNode(iri)
      strictEqual(typeof term.toString, 'function')
    })
    it('should return the IRI', () => {
      const iri = 'http://example.org'
      const term = new NamedNode(iri)
      strictEqual(term.toString(), iri)
    })
  })
  describe('.toURL', () => {
    it('should be a method', () => {
      const iri = 'http://example.org/path?query=value'
      const term = new NamedNode(iri)
      strictEqual(typeof term.toURL, 'function')
    })
    it('should return a URL object', () => {
      const iri = 'http://example.org/path?query=value'
      const term = new NamedNode(iri)
      strictEqual(term.toURL() instanceof URL, true)
    })
    it('should return a URL object with IRI of the NamedNode', () => {
      const iri = 'http://example.org/path?query=value'
      const term = new NamedNode(iri)
      strictEqual(term.toURL().toString(), iri)
    })
  })
})

================
File: test/Quad.test.js
================
import { strictEqual } from 'assert'
import { describe, it } from 'mocha'
import Quad from '../lib/Quad.js'
import example from './support/exampleData.js'
describe('Quad', () => {
  describe('.toCanonical', () => {
    it('should return a canonical representation', () => {
      const quad = new Quad(example.subject, example.predicate, example.object, example.graph)
      const quadNT = `${example.subject.toCanonical()} ${example.predicate.toCanonical()} ${example.object.toCanonical()} ${example.graph.toCanonical()} .`
      strictEqual(quad.toCanonical(), quadNT)
    })
    it('should skip the graph if it\'s a DefaultGraph', () => {
      const quad = new Quad(example.subject, example.predicate, example.object)
      const quadNT = `${example.subject.toCanonical()} ${example.predicate.toCanonical()} ${example.object.toCanonical()} .`
      strictEqual(quad.toCanonical(), quadNT)
    })
  })
  describe('.toString', () => {
    it('should return a canonical representation', () => {
      const quad = new Quad(example.subject, example.predicate, example.object, example.graph)
      const quadNT = `${example.subject.toCanonical()} ${example.predicate.toCanonical()} ${example.object.toCanonical()} ${example.graph.toCanonical()} .`
      strictEqual(quad.toString(), quadNT)
    })
    it('should skip the graph if it\'s a DefaultGraph', () => {
      const quad = new Quad(example.subject, example.predicate, example.object)
      const quadNT = `${example.subject.toCanonical()} ${example.predicate.toCanonical()} ${example.object.toCanonical()} .`
      strictEqual(quad.toString(), quadNT)
    })
  })
})

================
File: test/Variable.test.js
================
import { strictEqual } from 'assert'
import { describe, it } from 'mocha'
import Variable from '../lib/Variable.js'
describe('Variable', () => {
  describe('.toCanonical', () => {
    it('should be a method', () => {
      const term = new Variable('v')
      strictEqual(typeof term.toCanonical, 'function')
    })
    it('should return the name prefixed with a question mark', () => {
      const name = 'v'
      const term = new Variable(name)
      strictEqual(term.toCanonical(), '?' + name)
    })
  })
  describe('.toString', () => {
    it('should be a method', () => {
      const term = new Variable('v')
      strictEqual(typeof term.toString, 'function')
    })
    it('should return the name prefixed with a question mark', () => {
      const name = 'v'
      const term = new Variable(name)
      strictEqual(term.toString(), '?' + name)
    })
  })
})

================
File: test/fetch.test.js
================
import { strictEqual } from 'assert'
import { describe, it } from 'mocha'
import decode from 'stream-chunks/decode.js'
import fetch from '../lib/fetch.js'
describe('fetch', () => {
  it('should be a function', () => {
    strictEqual(typeof fetch, 'function')
  })
  it('should read the content of a file', async () => {
    const expected = '<http://example.org/subject>  <http://example.org/predicate> "object".'
    const res = await fetch(new URL('support/example.nt', import.meta.url))
    const result = await decode(res.body)
    strictEqual(result.trim(), expected)
  })
  it('should return the correct content type', async () => {
    const res = await fetch(new URL('support/example.nt', import.meta.url))
    strictEqual(res.headers.get('content-type'), 'application/n-triples')
  })
})

================
File: test/support/example.nt
================
<http://example.org/subject>  <http://example.org/predicate> "object".

================
File: test/support/exampleData.js
================
import rdf from '../../index.js'
const example = {
  subject: rdf.namedNode('http://example.org/subject'),
  subject1: rdf.namedNode('http://example.org/subject1'),
  subject2: rdf.namedNode('http://example.org/subject2'),
  subject3: rdf.namedNode('http://example.org/subject3'),
  predicate: rdf.namedNode('http://example.org/predicate'),
  predicate1: rdf.namedNode('http://example.org/predicate1'),
  predicate2: rdf.namedNode('http://example.org/predicate2'),
  predicate3: rdf.namedNode('http://example.org/predicate3'),
  object: rdf.literal('object'),
  object1: rdf.literal('1'),
  object2: rdf.literal('2'),
  object3: rdf.literal('3'),
  graph: rdf.namedNode('http://example.org/graph'),
  graph1: rdf.namedNode('http://example.org/graph1'),
  graph2: rdf.namedNode('http://example.org/graph2'),
  graph3: rdf.namedNode('http://example.org/graph3')
}
example.quad = rdf.quad(example.subject, example.predicate, example.object, example.graph)
example.quad1 = rdf.quad(example.subject, example.predicate, example.object1, example.graph)
example.quad2 = rdf.quad(example.subject, example.predicate, example.object2, example.graph)
example.quad3 = rdf.quad(example.subject, example.predicate, example.object3, example.graph)
export default example

================
File: test/support/spogFilter.js
================
function spogFilter (subject, predicate, object, graph) {
  return quad => {
    return (!subject || quad.subject.equals(subject)) &&
      (!predicate || quad.predicate.equals(predicate)) &&
      (!object || quad.object.equals(object)) &&
      (!graph || quad.graph.equals(graph))
  }
}
export default spogFilter

================
File: test/test.js
================
import { doesNotThrow, strictEqual } from 'assert'
import { describe, it } from 'mocha'
import rdf from '../index.js'
describe('rdf-ext', () => {
  it('should implement the DataModelFactory interface', () => {
    strictEqual(typeof rdf.blankNode, 'function')
    strictEqual(typeof rdf.defaultGraph, 'function')
    strictEqual(typeof rdf.fromQuad, 'function')
    strictEqual(typeof rdf.fromTerm, 'function')
    strictEqual(typeof rdf.literal, 'function')
    strictEqual(typeof rdf.namedNode, 'function')
    strictEqual(typeof rdf.quad, 'function')
    strictEqual(typeof rdf.variable, 'function')
  })
  it('should implement the DatasetFactory interface', () => {
    strictEqual(typeof rdf.dataset, 'function')
  })
  it('should implement the FetchFactory interface', () => {
    strictEqual(typeof rdf.fetch, 'function')
  })
  it('should implement the FormatsFactory interface', () => {
    strictEqual(typeof rdf.formats, 'object')
  })
  it('should implement the GrapoiFactory interface', () => {
    strictEqual(typeof rdf.grapoi, 'function')
  })
  it('should implement the IoFactory interface', () => {
    strictEqual(typeof rdf.io.dataset, 'object')
    strictEqual(typeof rdf.io.dataset.fromText, 'function')
    strictEqual(typeof rdf.io.dataset.fromURL, 'function')
    strictEqual(typeof rdf.io.dataset.toText, 'function')
    strictEqual(typeof rdf.io.dataset.toURL, 'function')
    strictEqual(typeof rdf.io.stream, 'object')
    strictEqual(typeof rdf.io.stream.fromText, 'function')
    strictEqual(typeof rdf.io.stream.fromURL, 'function')
    strictEqual(typeof rdf.io.stream.toText, 'function')
    strictEqual(typeof rdf.io.stream.toURL, 'function')
  })
  it('should implement the NamespaceFactory interface', () => {
    strictEqual(typeof rdf.namespace, 'function')
  })
  it('should implement the PrefixMapFactory interface', () => {
    strictEqual(typeof rdf.prefixes, 'object')
    strictEqual(typeof rdf.prefixMap, 'function')
  })
  it('should implement the ScoreFactory interface', () => {
    strictEqual(typeof rdf.score, 'object')
    strictEqual(typeof rdf.score.sort, 'function')
  })
  it('should implement the TermMapFactory interface', () => {
    strictEqual(typeof rdf.termMap, 'function')
  })
  it('should implement the TermSetFactory interface', () => {
    strictEqual(typeof rdf.termSet, 'function')
  })
  it('should implement the TraverserFactory interface', () => {
    strictEqual(typeof rdf.traverser, 'function')
  })
  it('should bind the factory methods', () => {
    const { blankNode } = rdf
    doesNotThrow(() => {
      blankNode()
    })
  })
})
