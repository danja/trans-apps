This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-25T15:55:47.272Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------
User Provided Header:
-----------------------
claude-json-converter source code

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
processors/
  JSONProcessorsFactory.js
  JSONReader.js
  JSONWalker.js
  MarkdownFormatter.js
  ProcessorTemplate.js
  TemplateProcessorsFactory.js
  TurtleFormatter.js
scripts/
  test-runner.js
about.md
manifest.ttl
package.json
processors-config.ttl
test-spec.js
transmissions.ttl
users.json

================================================================
Repository Files
================================================================

================
File: processors/JSONProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import JSONReader from './JSONReader.js'
import JSONWalker from './JSONWalker.js'
import MarkdownFormatter from './MarkdownFormatter.js'
import TurtleFormatter from './TurtleFormatter.js'

class JSONProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.t.JSONReader)) {
            return new JSONReader(config)
        }
        if (type.equals(ns.t.JSONWalker)) {
            return new JSONWalker(config)
        }
        if (type.equals(ns.t.MarkdownFormatter)) {
            return new MarkdownFormatter(config)
        }
        if (type.equals(ns.t.TurtleFormatter)) {
            return new TurtleFormatter(config)
        }
        return false
    }
}

export default JSONProcessorsFactory

================
File: processors/JSONReader.js
================
import { readFile } from 'node:fs/promises'
import logger from '../../utils/Logger.js'
import ProcessProcessor from '../base/ProcessProcessor.js'

class JSONReader extends ProcessProcessor {
    constructor(config) {
        super(config)
    }

    async execute(message) {
        try {
            const filePath = message.sourceFile
            logger.debug('Reading JSON from: ' + filePath)
            const content = await readFile(filePath, 'utf8')
            message.content = JSON.parse(content)
            this.emit('message', message)
        } catch (err) {
            logger.error("JSONReader.execute error: " + err.message)
            throw err
        }
    }
}

export default JSONReader

================
File: processors/JSONWalker.js
================
import logger from '../../utils/Logger.js'
import ProcessProcessor from '../base/ProcessProcessor.js'

class JSONWalker extends ProcessProcessor {
    constructor(config) {
        super(config)
    }

    async execute(message) {
        try {
            const content = message.content
            if (!content || typeof content !== 'object') {
                throw new Error('Invalid JSON content')
            }


            for (const item of Object.values(content)) {
                const clonedMessage = structuredClone(message)
                clonedMessage.currentItem = item
                this.emit('message', clonedMessage)
            }


            message.done = true
            this.emit('message', message)
        } catch (err) {
            logger.error("JSONWalker.execute error: " + err.message)
            throw err
        }
    }
}

export default JSONWalker

================
File: processors/MarkdownFormatter.js
================
import logger from '../../utils/Logger.js'
import ProcessProcessor from '../base/ProcessProcessor.js'

class MarkdownFormatter extends ProcessProcessor {
    constructor(config) {
        super(config)
    }

    async execute(message) {
        try {
            const item = message.currentItem
            if (!item) {
                return
            }


            const markdown = this.formatMarkdown(item)
            message.content = markdown
            message.targetFile = `${item.id}.md`

            this.emit('message', message)
        } catch (err) {
            logger.error("MarkdownFormatter.execute error: " + err.message)
            throw err
        }
    }

    formatMarkdown(item) {
        const lines = []
        lines.push(`# ${item.title || 'Untitled'}`)
        lines.push('')

        for (const [key, value] of Object.entries(item)) {
            if (key !== 'title' && value !== null) {
                lines.push(`## ${key}`)
                lines.push('')
                lines.push(typeof value === 'object' ? JSON.stringify(value, null, 2) : value.toString())
                lines.push('')
            }
        }

        return lines.join('\n')
    }
}

export default MarkdownFormatter

================
File: processors/ProcessorTemplate.js
================
import { readFile } from 'node:fs/promises'

import logger from '../../utils/Logger.js'
import Processor from '../base/Processor.js'









class ProcessorExample extends Processor {





    constructor(config) {
        super(config)
    }





    async execute(message) {
        logger.setLogLevel('debug')


        this.emit('message', message)
    } catch(err) {
        logger.error("ProcessorExample.execute error : " + err.message)
    }
}

export default ProcessorExample

================
File: processors/TemplateProcessorsFactory.js
================
import logger from '../../utils/Logger.js'
import ns from '../../utils/ns.js'

import Processors from './ProcessorsTemplate.js'




class TemplateProcessorsFactory {
    static createProcessor(type, config) {
        if (type.equals(ns.t.ProcessorsTemplate)) {
            return new ProcessorsTemplate(config)
        }
        return false
    }
}
export default TemplateProcessorsFactory

================
File: processors/TurtleFormatter.js
================
import logger from '../../utils/Logger.js'
import ProcessProcessor from '../base/ProcessProcessor.js'

class TurtleFormatter extends ProcessProcessor {
    constructor(config) {
        super(config)
        this.baseURI = config.baseURI || 'http://example.org/'
    }

    async execute(message) {
        try {
            const item = message.currentItem
            if (!item) {
                return
            }


            const turtle = this.formatTurtle(item)
            message.content = turtle
            message.targetFile = `${item.id}.ttl`

            this.emit('message', message)
        } catch (err) {
            logger.error("TurtleFormatter.execute error: " + err.message)
            throw err
        }
    }

    formatTurtle(item) {
        const lines = []
        lines.push('@prefix : <http://example.org/ns#> .')
        lines.push('@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .')
        lines.push('')

        const subject = `<${this.baseURI}${item.id}>`
        lines.push(`${subject} a :Item ;`)

        const entries = Object.entries(item)
        entries.forEach(([key, value], index) => {
            if (value !== null) {
                const isLast = index === entries.length - 1
                const literal = typeof value === 'string' ?
                    `"${value.replace(/"/g, '\\"')}"` :
                    `"${JSON.stringify(value)}"`
                lines.push(`    :${key} ${literal}${isLast ? ' .' : ' ;'}`)
            }
        })

        return lines.join('\n')
    }
}

export default TurtleFormatter

================
File: scripts/test-runner.js
================
import path from 'path'
import { fileURLToPath } from 'url'
import TransmissionBuilder from '../../../transmissions/src/engine/TransmissionBuilder.js'
import logger from '../../../transmissions/src/utils/Logger.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

async function main() {
    logger.setLogLevel('debug')

    const transmissionConfigFile = path.join(__dirname, 'transmissions.ttl')
    const processorsConfigFile = path.join(__dirname, 'processors-config.ttl')

    try {
        const transmissions = await TransmissionBuilder.build(
            transmissionConfigFile,
            processorsConfigFile,
            path.join(__dirname, 'processors')
        )

        const message = {
            sourceFile: path.join(__dirname, 'test-data/sample.json')
        }

        for (const transmission of transmissions) {
            await transmission.execute(message)
        }
    } catch (error) {
        logger.error('Error:', error)
        logger.debug('Error details:', error.stack)
    }
}

main().catch(console.error)

================
File: about.md
================
```sh
cd ~/github-danny/transmissions/
 ./trans ../trans-apps/templates/new-app
```

================
File: manifest.ttl
================
### manifest.ttl  ###

#### from danny.ayers.name 
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .

# SIOC 

@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix fs: <http://purl.org/stuff/filesystem/> .
@prefix pc: <http://purl.org/stuff/postcraft/> .
@prefix t: <http://hyperdata.it/transmissions/> . # for custom terms & instances

<https://danny.ayers.name> a pc:Site ;
    rdfs:label "danny.ayers.name" ;
    dcterms:title "Rawer" ;
    pc:contains <https://danny.ayers.name/home> ;  # maybe
    pc:includes t:PostContent . # maybe
    
# this should maybe give the contentgroup a renderType, indirect with template etc

# ENTRIES CONTENT
t:PostContent a pc:ContentGroup ; 
    rdfs:label "entries" ;
    pc:site <https://danny.ayers.name> ;
    pc:subdir "home" ; # better property name?
    fs:sourceDirectory "content-raw/entries" ; # SOURCE DIR HERE journal, entries
    fs:targetDirectory "cache/entries" ;
    pc:template "layouts/mediocre/templates/entry-content_template.njk" .

# ENTRIES PAGES
t:PostPages a pc:ContentGroup ;
    pc:site <https://danny.ayers.name> ;
    fs:targetDirectory "public/home/entries" ;
    pc:template "layouts/mediocre/templates/entry-page_template.njk" .

# ENTRIES MAIN PAGE
t:IndexPage a pc:ContentGroup ; # TODO naming!
    pc:site <https://danny.ayers.name> ;
    fs:filepath "public/home/index.html" ;
    pc:template "layouts/mediocre/templates/index-page_template.njk" .

#################################
# ENTRIES CONTENT
t:TodoContent a pc:ContentGroup ; 
    rdfs:label "todo" ;
    pc:site <https://danny.ayers.name> ;
    pc:subdir "home" ; # better property name?
    fs:sourceDirectory "content-raw/todo" ; # SOURCE DIR HERE journal, entries
    fs:targetDirectory "cache/todo" ;
    pc:template "layouts/mediocre/templates/entry-content_template.njk" .

####################################

# STYLES ETC currently just done with FileCopy
t:CSS a pc:StaticGroup ;
    pc:site <https://danny.ayers.name> ;
    fs:sourceDirectory "layouts/mediocre/css" ;
    fs:targetDirectory "public/home/css" .

t:fonts a pc:StaticGroup ;
    pc:site <https://danny.ayers.name> ;
    fs:sourceDirectory "layouts/mediocre/fonts" ;
    fs:targetDirectory "public/home/js" .

t:JS a pc:StaticGroup ;
    pc:site <https://danny.ayers.name> ;
    fs:sourceDirectory "layouts/mediocre/js" ;
    fs:targetDirectory "public/home/js" .


# pinned - not yet implemented
<https://danny.ayers.name/index> a pc:SpecialCase ;
    pc:state "pinned" ;
    fs:sourceFile "home/2023-10-27_hello.md" ;
    fs:targetFile "public/home/2023-10-27_hello.html" .
#     pc:template "layouts/mediocre/mediocre-posts_template.html" .

================
File: package.json
================
{
    "name": "new-app",
    "version": "1.0.0",
    "type": "module",
    "main": "runner.js",
    "scripts": {
        "start": "node test-runner.js",
        "test": "echo \"Error: no test specified\" && exit 1",
        "rp": "repopack --verbose -c repopack.config.json ."
    },
    "keywords": [],
    "author": "Danny Ayers",
    "license": "MIT",
    "description": "A minimal app to use as a template"
}

================
File: processors-config.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix t: <http://hyperdata.it/transmissions/> .

t:baseConfig a trm:ServiceConfig ;
    trm:key t:baseConfig ;
    trm:baseURI "http://example.org/data/" .

t:outputConfig a trm:ServiceConfig ;
    trm:key t:outputConfig ;
    trm:markdownDir "output/markdown/" ;
    trm:turtleDir "output/turtle/" .

================
File: test-spec.js
================
import { expect } from 'chai'
import path from 'path'
import fs from 'fs/promises'
import { fileURLToPath } from 'url'

import JSONReader from '../processors/JSONReader.js'
import JSONWalker from '../processors/JSONWalker.js'
import MarkdownFormatter from '../processors/MarkdownFormatter.js'
import TurtleFormatter from '../processors/TurtleFormatter.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

describe('JSON Converter', () => {
    const config = {}
    let testData

    beforeAll(async () => {
        const testFile = path.join(__dirname, 'fixtures/test.json')
        const content = await fs.readFile(testFile, 'utf8')
        testData = JSON.parse(content)
    })

    describe('JSONReader', () => {
        it('should read and parse JSON file', async () => {
            const reader = new JSONReader(config)
            const message = { sourceFile: path.join(__dirname, 'fixtures/test.json') }

            const result = await reader.execute(message)
            expect(result.content).to.deep.equal(testData)
        })
    })

    describe('JSONWalker', () => {
        it('should walk JSON structure and emit messages', async () => {
            const walker = new JSONWalker(config)
            const message = { content: testData }

            const outputs = []
            walker.on('message', msg => outputs.push(msg))

            await walker.execute(message)
            expect(outputs.length).to.be.greaterThan(0)
        })
    })

    describe('MarkdownFormatter', () => {
        it('should format items as markdown', async () => {
            const formatter = new MarkdownFormatter(config)
            const message = { currentItem: testData[0] }

            const result = await formatter.execute(message)
            expect(result.content).to.include('# ')
            expect(result.targetFile).to.match(/\.md$/)
        })
    })

    describe('TurtleFormatter', () => {
        it('should format items as turtle', async () => {
            const formatter = new TurtleFormatter(config)
            const message = { currentItem: testData[0] }

            const result = await formatter.execute(message)
            expect(result.content).to.include('@prefix')
            expect(result.targetFile).to.match(/\.ttl$/)
        })
    })
})

================
File: transmissions.ttl
================
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix trm: <http://purl.org/stuff/transmission/> .
@prefix : <http://hyperdata.it/transmissions/> .

:json_converter a trm:Pipeline ;
    trm:pipe (:s1 :s2 :s3 :s4a :s5a :s6a :s4b :s5b :s6b) .

:s1 a :JSONReader .
:s2 a :JSONWalker .
:s3 a :Fork .

# Markdown pipeline
:s4a a :MarkdownFormatter .
:s5a a :FileWriter .
:s6a a :DeadEnd .

# Turtle pipeline  
:s4b a :TurtleFormatter .
:s5b a :FileWriter .
:s6b a :DeadEnd .

================
File: users.json
================
[{"uuid": "dc67aa7d-f71f-4232-afb3-7f2688ac68f7", "full_name": "Danny Ayers", "email_address": "danny.ayers@gmail.com", "verified_phone_number": null}]
